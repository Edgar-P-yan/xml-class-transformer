{"version":3,"file":"index.umd.js","sources":["../src/index.ts"],"sourcesContent":["import xmljs from 'xml-js';\nimport type { DeclarationAttributes } from 'xml-js';\n\nexport type AnyClass = { new (): any };\n\nexport type XmlType = typeof String | typeof Number | typeof Boolean | AnyClass;\n\nexport interface XmlEntityOptions {\n  /**\n   * xmlns attribute value.\n   * This is just a shortcut for @XmlAttribute({ name: 'xmlns', value: '...' }) property decorator.\n   */\n  xmlns?: string;\n\n  /**\n   * XML element name.\n   * If not specified, the class name will be used.\n   */\n  name?: string;\n}\n\nexport interface XmlPropertyOptions {\n  /**\n   * Specify primitive type or class type for parsing and serializing.\n   * @example\n   * { type: String }\n   *\n   * You can also specify multiple classes, then the one whose name matches the element name will be selected.\n   * @example\n   * { type: [Version, DeleteMarker] }\n   */\n  type: XmlType | XmlType[];\n\n  /**\n   * If true, the property will be parsed and serialized as an array.\n   * Not compatible with `attr` and `chardata` options.\n   */\n  array?: boolean;\n\n  /**\n   * XML element name.\n   * If not specified, the property name will be used.\n   * It is highly recommended to specify it explicitly.\n   *\n   * Not compatible with `chardata` options.\n   */\n  name?: string | undefined;\n\n  /**\n   * If true, the property will be parsed and serialized as an attribute.\n   */\n  attr?: boolean;\n\n  /**\n   * If true, the property will be parsed and serialized as a character data.\n   * Not compatible with `array` and `attr` options.\n   *\n   * It's only useful when you parse elements with a text node and no attributes.\n   *\n   * @example\n   * *XmlEntity({ name: 'Comment' })\n   * class Comment {\n   *  *XmlProperty({ chardata: true })\n   *  text: string;\n   *\n   *  *XmlProperty({ name: 'lang', attr: true })\n   *  lenguage: string;\n   *\n   *  constructor(d?: Comment) {\n   *   Object.assign(this, d || {});\n   *  }\n   * }\n   *\n   * classToXml(\n   *  new Comment({\n   *    text: 'This is awesome',\n   *    lenguage: 'en',\n   *  })\n   * )\n   *\n   * // Output:\n   * <Comment lang=\"en\">This is awesome</Comment>\n   */\n  chardata?: boolean;\n}\n\ntype ClassMetadatas = {\n  properties: Map<string, XmlPropertyOptions>;\n  entity: XmlEntityOptions;\n};\n\nconst registry: Map<AnyClass, ClassMetadatas> = new Map();\n\n/**\n * Class decorator\n */\nexport function XmlEntity(opts?: XmlEntityOptions): ClassDecorator {\n  return (target: any): any => {\n    opts = opts || {};\n\n    opts.name = opts.name || target.name;\n\n    if (!opts.name) {\n      throw new Error(\n        `Failed to get the element name for class ${target}. Specify it with @XmlEntity({ name: '...' }) decorator.`,\n      );\n    }\n\n    const metadata = registry.get(target);\n\n    if (metadata) {\n      metadata.entity = opts;\n    } else {\n      registry.set(target, {\n        entity: opts,\n        properties: new Map(),\n      });\n    }\n\n    return target;\n  };\n}\n\n/**\n * Class property decorator\n */\nexport function XmlProperty(opts: XmlPropertyOptions): PropertyDecorator {\n  return (target: { constructor: any }, propertyKey: string | symbol): void => {\n    opts.name === opts.name || propertyKey;\n\n    if (typeof propertyKey !== 'string') {\n      throw new TypeError(\n        `Can't use @XmlProperty({...}) decorator on symbol property at ${\n          target.constructor.name\n        }#${propertyKey.toString()}`,\n      );\n    }\n\n    const metadata = registry.get(target.constructor);\n    if (metadata) {\n      metadata.properties.set(propertyKey, opts);\n    } else {\n      registry.set(target.constructor, {\n        properties: new Map([[propertyKey, opts]]),\n        entity: {},\n      });\n    }\n  };\n}\n\nexport function xmlToClass<T extends AnyClass>(\n  xml: string,\n  _class: T,\n): InstanceType<T> {\n  const parsed = xmljs.xml2js(xml, {\n    compact: false,\n    alwaysArray: true,\n  }) as xmljs.Element;\n\n  const firstElement = parsed.elements?.[0];\n\n  if (!firstElement) {\n    throw new Error('No elements found in xml.');\n  }\n\n  return xmlToClassInternal(firstElement, _class);\n}\n\nfunction xmlToClassInternal(element: xmljs.Element, _class: any): any {\n  if ([String, Number, Boolean].includes(_class)) {\n    let value: unknown = undefined;\n\n    const text = getTextForElem(element)?.toString();\n\n    if (_class === String) {\n      value = text;\n    } else if (_class === Number) {\n      value = text ? parseInt(text, 10) : undefined;\n    } else if (_class === Boolean) {\n      value = text ? text === 'true' : undefined;\n    }\n\n    return value;\n  }\n\n  const metadatas = registry.get(_class);\n\n  if (!metadatas) {\n    throw new Error('Unknown class ' + _class);\n  }\n\n  const inst = new _class();\n\n  metadatas.properties.forEach((metadata, key) => {\n    if (metadata.attr) {\n      if (!metadata.name) {\n        throw new Error(\n          `No name is specified for attribute ${key}. Specify it with @XmlProperty({ name: '...' }) decorator.`,\n        );\n      }\n\n      const attr = element.attributes?.[metadata.name];\n\n      if (attr) {\n        inst[key] = attr;\n      } else {\n        inst[key] = undefined;\n      }\n    } else if (metadata.chardata) {\n      inst[key] = xmlToClassInternal(element, metadata.type);\n    } else if (metadata.array) {\n      if (Array.isArray(metadata.type)) {\n        const tagNameToClassType: Map<string, any> = new Map();\n\n        metadata.type.forEach((classType) => {\n          const classTypeMetadata = registry.get(classType);\n\n          if (!classTypeMetadata) {\n            throw errUnknownClass(classType);\n          }\n\n          const tagName = classTypeMetadata.entity.name;\n\n          if (!tagName) {\n            throw new Error(\n              `No name is specified for ${classType}. Specify it with @XmlEntity({ name: '...' }) decorator.`,\n            );\n          }\n\n          tagNameToClassType.set(tagName, classType);\n        });\n\n        const possibleTagNames = [...tagNameToClassType.keys()];\n\n        const resolvedValues: any[] = [];\n\n        element.elements?.forEach((el) => {\n          if (el.name && possibleTagNames.includes(el.name)) {\n            const classType = tagNameToClassType.get(el.name);\n\n            const entity = xmlToClassInternal(el, classType);\n\n            resolvedValues.push(entity);\n          }\n        });\n\n        inst[key] = resolvedValues;\n      } else {\n        const elems =\n          element.elements?.filter((e) => e.name === metadata.name) || [];\n\n        const resolvedValues: any[] = [];\n\n        elems.forEach((el) => {\n          const entity = xmlToClassInternal(el, metadata.type as XmlType);\n\n          resolvedValues.push(entity);\n        });\n\n        inst[key] = resolvedValues;\n      }\n    } else {\n      const el = element.elements?.find((el) => el.name === metadata.name);\n\n      if (el) {\n        const value: any = xmlToClassInternal(el, metadata.type);\n\n        inst[key] = value;\n      } else {\n        inst[key] = undefined;\n      }\n    }\n  });\n\n  return inst;\n}\n\nfunction getTextForElem(el: xmljs.Element): string | undefined {\n  return el.elements?.find((e) => e.type === 'text')?.text as string;\n}\n\nexport interface ClassToXmlOptions extends xmljs.Options.JS2XML {\n  /**\n   * Whether to include the default declaration line `<?xml version=\"1.0\" encoding=\"UTF-8\"?>` or not.\n   * @default true\n   */\n  declaration?:\n    | boolean\n    | {\n        attributes?: DeclarationAttributes;\n      };\n}\n\nexport function classToXml(entity: any, options?: ClassToXmlOptions): string {\n  const tree = buildXmlFromClassInternal(entity, '', entity.constructor);\n\n  const rootElem: xmljs.Element = { elements: [tree] };\n\n  if (options?.declaration !== false) {\n    if (\n      typeof options?.declaration === 'object' &&\n      options?.declaration !== null\n    ) {\n      rootElem.declaration = options.declaration;\n    } else {\n      rootElem.declaration = {\n        attributes: { version: '1.0', encoding: 'UTF-8' },\n      };\n    }\n  }\n\n  return xmljs.js2xml(rootElem, options);\n}\n\nfunction buildXmlFromClassInternal(\n  entity: any,\n  name: string,\n  entityConstructor: any,\n): xmljs.Element {\n  if ([String, Number, Boolean].includes(entityConstructor)) {\n    const text = entity === null ? '' : entity?.toString();\n\n    return {\n      type: 'element',\n      name: name,\n      elements: [\n        {\n          type: 'text',\n          text,\n        },\n      ],\n    };\n  }\n\n  const meta = registry.get(entityConstructor);\n\n  if (!meta) {\n    throw errUnknownClass(entityConstructor);\n  }\n\n  const elemName = name || meta.entity.name;\n\n  if (!elemName) {\n    throw new Error(\n      `No name is specified for ${entityConstructor}. Specify it with @XmlEntity({ name: '...' }) decorator.`,\n    );\n  }\n\n  const children: xmljs.Element[] = [];\n\n  const attributes: xmljs.Attributes = {};\n\n  meta.properties.forEach((opts, classKey) => {\n    if (entity[classKey] === undefined) {\n      return;\n    }\n\n    if (opts.attr) {\n      if (!opts.name) {\n        throw new Error(\n          `No name is specified for property ${classKey}. Specify it with @XmlProperty({ name: '...' }) decorator.`,\n        );\n      }\n      attributes[opts.name] =\n        entity[classKey] === null ? '' : entity[classKey].toString();\n    } else if (opts.chardata) {\n      children.push({\n        type: 'text',\n        text: entity[classKey] === null ? '' : entity[classKey].toString(),\n      });\n    } else if (opts.array) {\n      entity[classKey]?.forEach((e: any) => {\n        // If opts.type is an array then we can't guess required class out of it.\n        // In those cases users should use class constructors (aka new MyEntity({...}))\n        // so the library can guess the class type just by looking at myEntity.constructor\n        const classConstructor = Array.isArray(opts.type)\n          ? e.constructor\n          : opts.type;\n        children.push(\n          buildXmlFromClassInternal(e, opts.name!, classConstructor),\n        );\n      });\n    } else if ([String, Number, Boolean].includes(opts.type as any)) {\n      if (!opts.name) {\n        throw new Error(\n          `No name is specified for property ${classKey}. Specify it with @XmlProperty({ name: '...' }) decorator.`,\n        );\n      }\n      children.push(\n        buildXmlFromClassInternal(entity[opts.name], opts.name, opts.type),\n      );\n    } else {\n      children.push(\n        buildXmlFromClassInternal(entity[classKey], opts.name!, opts.type),\n      );\n    }\n  });\n\n  if (meta.entity.xmlns) {\n    attributes['xmlns'] = meta.entity.xmlns;\n  }\n\n  return {\n    type: 'element',\n    name: elemName,\n    attributes,\n    elements: children,\n  };\n}\n\nfunction errUnknownClass(classConstructor: any): Error {\n  return new Error(\n    `Class ${classConstructor} not found. Make sure there is @XmlEntity({...}) decorator on it, or @XmlProperty({...}) decorator on its properties.`,\n  );\n}\n"],"names":["xmljs"],"mappings":"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"}