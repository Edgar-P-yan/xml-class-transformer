{"version":3,"file":"index.umd.js","sources":["../src/class-metadata-registry.ts","../src/common.ts","../src/transform-class-to-xml.ts","../src/transform-xml-to-class.ts","../src/decorators.ts"],"sourcesContent":["import { InternalXmlPropertyOptions } from './internal-types';\nimport type { XmlClass, XmlElemOptions } from './types';\n\ntype ClassMetadatas = {\n  properties: Map<string, InternalXmlPropertyOptions>;\n  entity: XmlElemOptions;\n};\n\nexport class ClassMetadataRegistry {\n  private registry = new Map<XmlClass, ClassMetadatas>();\n\n  setEntityOptions(xClass: XmlClass, opts: XmlElemOptions): void {\n    const metadata = this.registry.get(xClass);\n\n    if (metadata) {\n      metadata.entity = opts;\n    } else {\n      this.registry.set(xClass, {\n        entity: opts,\n        properties: new Map(),\n      });\n    }\n  }\n\n  setPropertyOptions(\n    xClass: XmlClass,\n    propertyKey: string,\n    opts: InternalXmlPropertyOptions,\n  ): void {\n    const metadata = this.getOrCreate(xClass);\n\n    if (opts.comments) {\n      for (const [searchingPropKey, searchingOpts] of metadata.properties) {\n        if (searchingOpts.comments) {\n          throw new Error(\n            `xml-class-transformer: only one @XmlComment() decorator is allowed per class. ` +\n              `Can not define @XmlComment() decorator for  ` +\n              `${xClass.name}#${propertyKey} since it's already used for ` +\n              `${xClass.name}#${searchingPropKey}.`,\n          );\n        }\n      }\n    }\n\n    if (opts.name) {\n      for (const [searchingPropKey, searchingOpts] of metadata.properties) {\n        if (searchingOpts.name === opts.name) {\n          throw new Error(\n            `xml-class-transformer: can't use XML element name defined in ` +\n              `{ name: ${JSON.stringify(opts.name)} } for ` +\n              `${xClass.name}#${propertyKey} since it's already used for ` +\n              `${xClass.name}#${searchingPropKey}. Change it to something else.`,\n          );\n        }\n\n        // TODO: maybe support multiple chardata for multiple child text nodes inside an xml element.\n        // each of those chardata properties whould match the text node at the same position as the property itself.\n        // The same goes for not yet implemented comments and cdata.\n        if (opts.chardata && searchingOpts.chardata) {\n          throw new Error(\n            `xml-class-transformer: an XML element can have only one chardata property. ` +\n              `Both ${xClass.name}#${propertyKey} and ${xClass.name}#${searchingOpts.name} ` +\n              `are defined as chardata, which is not valid.`,\n          );\n        }\n      }\n    }\n\n    metadata.properties.set(propertyKey, opts);\n  }\n\n  private getOrCreate(xClass: XmlClass): ClassMetadatas {\n    const existing = this.registry.get(xClass);\n    if (existing) {\n      return existing;\n    } else {\n      const newMetadatas: ClassMetadatas = {\n        entity: {\n          name: xClass?.name,\n        },\n        properties: new Map(),\n      };\n\n      this.registry.set(xClass, newMetadatas);\n\n      return newMetadatas;\n    }\n  }\n\n  get(xClass: XmlClass): ClassMetadatas | undefined {\n    return this.registry.get(xClass);\n  }\n}\n\nexport const registry = new ClassMetadataRegistry();\n","import { XmlPrimitiveType, XmlType } from './types';\n\nexport function errUnknownClass(classConstructor: any): Error {\n  return new Error(\n    `xml-class-transformer: class \"${classConstructor}\" not found. Make sure there is a @XmlElem({...}) ` +\n      `decorator on it, or XmlChildElem, XmlAttribute, XmlChardata or XmlComments decorator on its properties.`,\n  );\n}\n\nexport function serializeUnionForLog(union: any[]): string {\n  return '[' + union.map((t) => t?.name ?? `${union}`).join(', ') + ']';\n}\n\nexport function isPrimitiveType(type: XmlType): type is XmlPrimitiveType {\n  return (\n    type === String || type === Number || type === BigInt || type === Boolean\n  );\n}\n","import xmljs from 'xml-js';\nimport { registry } from './class-metadata-registry';\nimport { ClassToXmlOptions, XmlType } from './types';\nimport { errUnknownClass, isPrimitiveType } from './common';\n\nexport function classToXml(entity: any, options?: ClassToXmlOptions): string {\n  const tree = classToXmlInternal(entity, '', entity.constructor);\n\n  const rootElem: xmljs.Element = { elements: [tree] };\n\n  if (options?.declaration !== false) {\n    if (\n      typeof options?.declaration === 'object' &&\n      options?.declaration !== null\n    ) {\n      rootElem.declaration = options.declaration;\n    } else {\n      rootElem.declaration = {\n        attributes: { version: '1.0', encoding: 'UTF-8' },\n      };\n    }\n  }\n\n  return xmljs.js2xml(rootElem, options);\n}\n\nfunction classToXmlInternal(\n  entity: any,\n  name: string | undefined,\n  entityConstructor: XmlType,\n): xmljs.Element {\n  if (isPrimitiveType(entityConstructor)) {\n    const text = entity === null ? '' : `${entity}`;\n\n    return {\n      type: 'element',\n      name: name!,\n      elements: [\n        {\n          type: 'text',\n          text,\n        },\n      ],\n    };\n  }\n\n  const meta = registry.get(entityConstructor);\n\n  if (!meta) {\n    throw errUnknownClass(entityConstructor);\n  }\n\n  const elemName = name || meta.entity.name;\n\n  if (!elemName) {\n    throw new Error(\n      `xml-class-transformer: no XML name is specified for the class \"${entityConstructor?.name}\". Specify it with the @XmlElem({ name: '...' }) decorator.`,\n    );\n  }\n\n  const children: xmljs.Element[] = [];\n\n  const attributes: xmljs.Attributes = {};\n\n  meta.properties.forEach((opts, classKey) => {\n    // Do not emit attribute if value is undefined,\n    if (entity[classKey] === undefined) {\n      return;\n    }\n\n    if (opts.comments) {\n      if (Array.isArray(entity[classKey])) {\n        for (const comment of entity[classKey]) {\n          children.push({\n            type: 'comment',\n            comment:\n              comment === null || comment === undefined ? '' : `${comment}`,\n          });\n        }\n      }\n    } else if (opts.attr) {\n      if (!opts.name) {\n        throw new Error(\n          `xml-class-transformer: no name is specified for the property ${entityConstructor?.name}#${classKey}. Specify it with the @XmlAttribute({ name: '...' }) decorator.`,\n        );\n      }\n\n      attributes[opts.name] =\n        entity[classKey] === null ? '' : `${entity[classKey]}`;\n    } else if (opts.chardata) {\n      children.push({\n        type: 'text',\n        text: entity[classKey] === null ? '' : `${entity[classKey]}`,\n      });\n    } else if (opts.array) {\n      if (entity[classKey] === null) {\n        return;\n      }\n\n      entity[classKey]?.forEach((e: any) => {\n        // Do not process null and undefined values in the array.\n        // When we impl support for primitive unions maybe this should change\n        if (!e) {\n          return;\n        }\n\n        // If it is a union then we can't guess required class out of it.\n        // In those cases users should give to the library actual class instances (aka new MyEntity({...}))\n        // so the library can guess the class type just by looking at the myEntity.constructor\n        const classConstructor = opts.union ? e.constructor : opts.type!();\n        // The opts.name will be undefined if !!opts.union, but thats ok.\n        children.push(classToXmlInternal(e, opts.name, classConstructor));\n      });\n    } else if (opts.type && isPrimitiveType(opts.type())) {\n      if (!opts.name) {\n        throw new Error(\n          `xml-class-transformer: no name is specified for property ${entityConstructor?.name}#${classKey}. Specify it with @XmlChildElem({ name: '...' }) decorator.`,\n        );\n      }\n      children.push(\n        classToXmlInternal(entity[classKey], opts.name, opts.type()),\n      );\n    } else if (opts.union) {\n      // should work with primitive types also\n      const classConstructor = entity[classKey].constructor;\n\n      children.push(\n        classToXmlInternal(entity[classKey], undefined, classConstructor),\n      );\n    } else {\n      // If null then just skip this embedded element for the current impl\n      // TODO: maybe non array unions are borken\n      if (entity[classKey] !== null) {\n        children.push(\n          classToXmlInternal(\n            entity[classKey],\n            opts.name,\n            opts.union ? entity[classKey].constructor : opts.type!(),\n          ),\n        );\n      }\n    }\n  });\n\n  if (meta.entity.xmlns) {\n    attributes['xmlns'] = meta.entity.xmlns;\n  }\n\n  return {\n    type: 'element',\n    name: elemName,\n    attributes,\n    elements: children,\n  };\n}\n","import xmljs from 'xml-js';\nimport { registry } from './class-metadata-registry';\nimport type { XmlClass, XmlPrimitiveType, XmlType } from './types';\nimport { errUnknownClass, isPrimitiveType } from './common';\n\nexport function xmlToClass<T extends XmlClass>(\n  xml: string,\n  _class: T,\n): InstanceType<T> {\n  const parsed = xmljs.xml2js(xml, {\n    compact: false,\n    alwaysArray: true,\n  }) as xmljs.Element;\n\n  const firstElement = parsed.elements?.[0];\n\n  if (!firstElement) {\n    throw new Error('No elements found in xml.');\n  }\n\n  return xmlToClassInternal(firstElement, _class);\n}\n\nfunction xmlToClassInternal(element: xmljs.Element, _class: XmlType): any {\n  if (isPrimitiveType(_class)) {\n    const text = getChardataFromElem(element);\n\n    return parsePrimitive(text, _class);\n  }\n\n  const metadatas = registry.get(_class);\n\n  if (!metadatas) {\n    throw new Error('Unknown class ' + _class);\n  }\n\n  const inst = new _class();\n\n  metadatas.properties.forEach((metadata, key) => {\n    if (metadata.comments) {\n      const commentsAccumulated: string[] = [];\n\n      for (const childElem of element.elements || []) {\n        if (childElem.type === 'comment') {\n          commentsAccumulated.push(childElem.comment || '');\n        }\n      }\n\n      inst[key] = commentsAccumulated;\n    } else if (metadata.attr) {\n      if (!metadata.name) {\n        throw new Error(\n          `xml-class-transformer: no name is specified for attribute ${key}. Specify it with @XmlAttribute({ name: '...' }) decorator.`,\n        );\n      }\n\n      const attr = element.attributes?.[metadata.name];\n\n      if (attr !== undefined && attr !== null) {\n        inst[key] = parsePrimitive(attr, metadata.type!() as XmlPrimitiveType);\n      } else {\n        // If the attribute property is undefined - it means\n        // that the attribute was not present in the xml.\n        inst[key] = undefined;\n      }\n    } else if (metadata.chardata) {\n      inst[key] = xmlToClassInternal(element, metadata.type!());\n    } else if (metadata.array) {\n      if (metadata.union) {\n        // TODO: optimize and cache this map:\n        const tagNameToClassType: Map<string, any> = new Map();\n\n        metadata.union().forEach((classType) => {\n          const classTypeMetadata = registry.get(classType);\n\n          if (!classTypeMetadata) {\n            throw errUnknownClass(classType);\n          }\n\n          const tagName = classTypeMetadata.entity.name;\n\n          if (!tagName) {\n            throw new Error(\n              `xml-class-transformer: no name is specified for ${classType}. Specify it with the @XmlElem({ name: '...' }) decorator.`,\n            );\n          }\n\n          tagNameToClassType.set(tagName, classType);\n        });\n\n        const possibleTagNames = [...tagNameToClassType.keys()];\n\n        const resolvedValues: any[] = [];\n\n        element.elements?.forEach((el) => {\n          if (el.name && possibleTagNames.includes(el.name)) {\n            const classType = tagNameToClassType.get(el.name);\n\n            const entity = xmlToClassInternal(el, classType);\n\n            resolvedValues.push(entity);\n          }\n        });\n\n        inst[key] = resolvedValues;\n      } else {\n        const elems =\n          element.elements?.filter((e) => e.name === metadata.name) || [];\n\n        const resolvedValues: any[] = [];\n\n        elems.forEach((el) => {\n          const entity = xmlToClassInternal(el, metadata.type!() as XmlType);\n\n          resolvedValues.push(entity);\n        });\n\n        inst[key] = resolvedValues;\n      }\n    } else if (metadata.union) {\n      // TODO: optimize and cache this map:\n      const tagNameToClassType: Map<string, any> = new Map();\n\n      metadata.union().forEach((classType) => {\n        const classTypeMetadata = registry.get(classType);\n\n        if (!classTypeMetadata) {\n          throw errUnknownClass(classType);\n        }\n\n        const tagName = classTypeMetadata.entity.name;\n\n        if (!tagName) {\n          throw new Error(\n            `xml-class-transformer: no name is specified for ${classType}. Specify it with the @XmlElem({ name: '...' }) decorator.`,\n          );\n        }\n\n        tagNameToClassType.set(tagName, classType);\n      });\n\n      const matchingXmlElement = element.elements?.find((el) => {\n        return el.name && tagNameToClassType.has(el.name);\n      });\n\n      inst[key] = matchingXmlElement\n        ? xmlToClassInternal(\n            matchingXmlElement,\n            tagNameToClassType.get(matchingXmlElement.name!)!,\n          )\n        : undefined;\n    } else {\n      const el = element.elements?.find((el) => el.name === metadata.name);\n\n      if (el) {\n        const value: any = xmlToClassInternal(el, metadata.type!());\n\n        inst[key] = value;\n      } else {\n        inst[key] = undefined;\n      }\n    }\n  });\n\n  return inst;\n}\n\nfunction getChardataFromElem(el: xmljs.Element): string {\n  let chardata = '';\n\n  for (const child of el.elements || []) {\n    if (child.type === 'text' && child.text) {\n      chardata += (child.text as string) || '';\n    }\n  }\n\n  return chardata;\n}\n\nfunction parsePrimitive(\n  // Support numbers also\n  value: string | number | undefined,\n  classConstructor: XmlPrimitiveType | undefined,\n): string | number | bigint | boolean | null | undefined {\n  let result: string | number | bigint | boolean | null | undefined = undefined;\n\n  if (value === undefined) {\n    result = undefined;\n  } else {\n    const castToStr = `${value}`;\n\n    if (classConstructor === Number) {\n      result =\n        // parse empty strings to nulls when the specified type is Number\n        // bacause there is no convenient way to represent an empty string as a number,\n        // there is an idea to convert them to 0, but it's an implicit and non obvious behaviour.\n        // Maybe a better idea would be to convert them to NaN just as parseFloat does.\n        castToStr === '' ? null : parseFloat(castToStr);\n    } else if (classConstructor === BigInt) {\n      result = castToStr === '' ? null : BigInt(castToStr);\n    } else if (classConstructor === Boolean) {\n      result = castToStr === '' ? null : castToStr === 'true';\n    } else {\n      // classConstructor is String or any other type, then fallback to String:\n      // In case of the string dont cast empty strings to nulls\n      result = castToStr;\n    }\n  }\n\n  return result;\n}\n","import { registry } from './class-metadata-registry';\nimport { isPrimitiveType, serializeUnionForLog } from './common';\nimport { InternalXmlPropertyOptions } from './internal-types';\nimport type {\n  XmlAttributeOptions,\n  XmlChardataOptions,\n  XmlChildElemOptions,\n  XmlElemOptions,\n} from './types';\n\n/**\n * A class decorator.\n * It can be omitted, but only if at least one Xml* property decorator is used on it's properties.\n *\n * @example\n * \\@XmlElem()\n * class EmptyXmlElement {}\n *\n * \\@XmlElem({ name: 'some-xml-element' })\n * class SomeXmlElement {\n *   \\@XmlChildElem()\n *   child: string;\n * }\n *\n * \\@XmlElem({ xmlns: 'http://s3.amazonaws.com/doc/2006-03-01/' })\n * class SomeXmlElement {\n *   \\@XmlChildElem()\n *   child: string;\n * }\n */\nexport function XmlElem(opts?: XmlElemOptions): ClassDecorator {\n  return (target: any): any => {\n    opts = opts || {};\n\n    opts.name = opts.name || target.name;\n\n    if (!opts.name) {\n      throw new Error(\n        `xml-class-transformer: Failed to get the element name for class ${target}. Specify it with @XmlElem({ name: '...' }) decorator.`,\n      );\n    }\n\n    registry.setEntityOptions(target, opts);\n\n    return target;\n  };\n}\n\n/**\n * Class property decorator.\n *\n * @example\n * class SomeElement {\n *   \\@XmlChildElem({ type: () => String })\n *   stringElem: string;\n *\n *   \\@XmlChildElem({ name: 'someOtherName', type: () => Number })\n *   numberElem: string;\n *\n *   \\@XmlChildElem({ type: () => NestedElem })\n *   nestedElem: NestedElem;\n * }\n */\nexport function XmlChildElem(opts: XmlChildElemOptions): PropertyDecorator {\n  return propertyDecoratorFactory('XmlChildElem', opts);\n}\n\n/**\n * Class property decorator.\n * For more details on options see {@link XmlAttributeOptions}\n *\n * @example\n * // a basic example\n * class SomeXmlElement {\n *   \\@XmlAttribute({ name: 'attributeName', type: () => String })\n *   attributeName: string;\n * }\n */\nexport function XmlAttribute(opts: XmlAttributeOptions): PropertyDecorator {\n  return propertyDecoratorFactory('XmlAttribute', {\n    ...opts,\n    attr: true,\n  });\n}\n\n/**\n * This decorator, when used on a class property, collects all the comments\n * from the provided XML, turns them into an array of strings and puts them into\n * that property. And vice-versa: at serialization that array of strings gets serialized to set of comments\n * in the resulting XML.\n *\n * @example\n * ```ts\n * class SomeElement {\n *   \\@XmlComments()\n *   comments?: string[];\n * }\n *\n * classToXml(\n *   new SomeElement({\n *     comments: ['some comment', 'some other comment']\n *   })\n * )\n * ```\n *\n * Output:\n * ```xml\n * <SomeElement>\n *   <!-- some comment -->\n *   <!-- some other comment -->\n * </SomeElement>\n *\n * ```\n */\nexport function XmlComments(): PropertyDecorator {\n  return (target: { constructor: any }, propertyKey: string | symbol): void => {\n    if (typeof propertyKey !== 'string') {\n      // Dont support symbols for now\n      throw new TypeError(\n        `xml-class-transformer: Can't use @XmlComments({...}) decorator on a symbol property ` +\n          `at ${target.constructor.name}#${propertyKey.toString()}`,\n      );\n    }\n\n    registry.setPropertyOptions(target.constructor, propertyKey, {\n      comments: true,\n    });\n  };\n}\n\n/**\n * The property will be parsed and serialized as a character data.\n * The \"type\" parameter can only be a primitive type: String, Number, Boolean.\n *\n * ```ts\n * \\@XmlElem({ name: 'Comment' })\n * class Comment {\n *   \\@XmlChardata({ type: () => String })\n *   text: string;\n *\n *   \\@XmlAttribute({ type: () => String, name: 'lang' })\n *   language: string;\n *\n *   constructor(d?: Comment) {\n *     Object.assign(this, d || {});\n *   }\n * }\n *\n * classToXml(\n *   new Comment({\n *     text: 'This is awesome',\n *     language: 'en',\n *   }),\n * )\n * ```\n *\n * Output:\n * ```xml\n * <Comment lang=\"en\">This is awesome</Comment>\n * ```\n */\nexport function XmlChardata(opts: XmlChardataOptions): PropertyDecorator {\n  return propertyDecoratorFactory('XmlChardata', {\n    ...opts,\n    chardata: true,\n  });\n}\n\nfunction propertyDecoratorFactory(\n  decoratorName: 'XmlAttribute' | 'XmlChildElem' | 'XmlChardata',\n  opts: InternalXmlPropertyOptions,\n): PropertyDecorator {\n  return (target: { constructor: any }, propertyKey: string | symbol): void => {\n    if (typeof propertyKey !== 'string') {\n      // Dont support symbols for now\n      throw new TypeError(\n        `xml-class-transformer: Can't use @${decoratorName}({...}) decorator on a symbol property ` +\n          `at ${target.constructor.name}#${propertyKey.toString()}`,\n      );\n    }\n\n    if (opts.union && opts.type) {\n      throw new TypeError(\n        `xml-class-transformer: The \"union\" option is not compatible with the \"type\" option at ` +\n          `${target.constructor.name}#${propertyKey.toString()}.`,\n      );\n    }\n\n    if (!opts.union && !opts.type) {\n      throw new TypeError(\n        `xml-class-transformer: No \"type\" or \"union\" was specified for the ` +\n          `${target.constructor.name}#${propertyKey.toString()}. Add it to ` +\n          `the @${decoratorName}({...}) decorator.`,\n      );\n    }\n\n    if (opts.union && !opts.union().length) {\n      throw new TypeError(\n        `xml-class-transformer: The \"union\" option in @${decoratorName}({ ... }) can't be empty ` +\n          `at ${\n            target.constructor.name\n          }#${propertyKey.toString()}. Either remove the \"union\" option or provide it with at least one type.`,\n      );\n    }\n\n    if (opts.union) {\n      if (opts.name) {\n        throw new TypeError(\n          `xml-class-transformer: The \"union\" option is not compatible with the \"name\" option at ` +\n            `${target.constructor.name}#${propertyKey.toString()}. ` +\n            `XML element names for the union members should be specified at ` +\n            `the union member classes.`,\n        );\n      }\n    } else {\n      opts.name = opts.name || propertyKey;\n    }\n\n    if (opts.union) {\n      // opts.union() at the moment of running this peace of code can potentially return\n      // undefineds as the value of some elements in case if there are circular dependencies.\n      // But the primitive values constructors (String, Number and Boolean) are always defined.\n      // So it's okay to check them like this:\n      const unionArr = opts.union();\n      const foundPrimitiveType = unionArr.find((type) => isPrimitiveType(type));\n\n      if (foundPrimitiveType) {\n        throw new TypeError(\n          `xml-class-transformer: unions of primitive types (String, Number or Boolean) are not supported. ` +\n            `Fix it in the decorator @${decoratorName}({ ` +\n            `union: ${serializeUnionForLog(unionArr)}, ... }) ` +\n            `at \"${target.constructor.name}#${propertyKey.toString()}\".`,\n        );\n      }\n    }\n\n    registry.setPropertyOptions(target.constructor, propertyKey, opts);\n  };\n}\n"],"names":["xmljs"],"mappings":"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"}