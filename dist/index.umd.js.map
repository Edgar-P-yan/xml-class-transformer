{"version":3,"file":"index.umd.js","sources":["../src/class-metadata-registry.ts","../src/common.ts","../src/transform-class-to-xml.ts","../src/transform-xml-to-class.ts","../src/decorators.ts"],"sourcesContent":["import type { AnyClass, XmlEntityOptions, XmlPropertyOptions } from './types';\n\ntype ClassMetadatas = {\n  properties: Map<string, XmlPropertyOptions>;\n  entity: XmlEntityOptions;\n};\n\nexport class ClassMetadataRegistry {\n  private registry = new Map<AnyClass, ClassMetadatas>();\n\n  setEntityOptions(clazz: AnyClass, opts: XmlEntityOptions): void {\n    const metadata = this.registry.get(clazz);\n\n    if (metadata) {\n      metadata.entity = opts;\n    } else {\n      this.registry.set(clazz, {\n        entity: opts,\n        properties: new Map(),\n      });\n    }\n  }\n\n  setPropertyOptions(\n    clazz: AnyClass,\n    propertyKey: string,\n    opts: XmlPropertyOptions,\n  ): void {\n    const metadata = this.getOrCreate(clazz);\n\n    if (opts.name) {\n      for (const [searchingPropKey, searchingOpts] of metadata.properties) {\n        if (searchingOpts.name === opts.name) {\n          throw new Error(\n            `xml-class-transformer: can't use XML element name defined in ` +\n              `{ name: ${JSON.stringify(opts.name)} } for ` +\n              `${clazz.name}#${propertyKey} since it's already used for ` +\n              `${clazz.name}#${searchingPropKey}. Change it to something else.`,\n          );\n        }\n\n        // TODO: maybe support multiple chardata for multiple child text nodes inside an xml element.\n        // each of those chardata properties whould match the text node at the same position as the property itself.\n        // The same goes for not yet implemented comments and cdata.\n        if (opts.chardata && searchingOpts.chardata) {\n          throw new Error(\n            `xml-class-transformer: an XML element can have only one chardata property. ` +\n              `Both ${clazz.name}#${propertyKey} and ${clazz.name}#${searchingOpts.name} ` +\n              `are defined as chardata, which is not valid.`,\n          );\n        }\n      }\n    }\n\n    metadata.properties.set(propertyKey, opts);\n  }\n\n  private getOrCreate(clazz: AnyClass): ClassMetadatas {\n    const existing = this.registry.get(clazz);\n    if (existing) {\n      return existing;\n    } else {\n      const newMetadatas: ClassMetadatas = {\n        entity: {\n          name: clazz?.name,\n        },\n        properties: new Map(),\n      };\n\n      this.registry.set(clazz, newMetadatas);\n\n      return newMetadatas;\n    }\n  }\n\n  get(clazz: AnyClass): ClassMetadatas | undefined {\n    return this.registry.get(clazz);\n  }\n}\n\nexport const registry = new ClassMetadataRegistry();\n","export function errUnknownClass(classConstructor: any): Error {\n  return new Error(\n    `Class \"${classConstructor}\" not found. Make sure there is a @XmlEntity({...}) decorator on it, or @XmlProperty({...}) decorator on its properties.`,\n  );\n}\n\nexport function serializeUnionForLog(union: any[]): string {\n  return (\n    '[' +\n    union\n      .map((t) =>\n        t === null ? 'null' : t === undefined ? 'undefined' : t.name,\n      )\n      .join(', ') +\n    ']'\n  );\n}\n","import xmljs from 'xml-js';\nimport { registry } from './class-metadata-registry';\nimport { ClassToXmlOptions } from './types';\nimport { errUnknownClass } from './common';\n\nexport function classToXml(entity: any, options?: ClassToXmlOptions): string {\n  const tree = classToXmlInternal(entity, '', entity.constructor);\n\n  const rootElem: xmljs.Element = { elements: [tree] };\n\n  if (options?.declaration !== false) {\n    if (\n      typeof options?.declaration === 'object' &&\n      options?.declaration !== null\n    ) {\n      rootElem.declaration = options.declaration;\n    } else {\n      rootElem.declaration = {\n        attributes: { version: '1.0', encoding: 'UTF-8' },\n      };\n    }\n  }\n\n  return xmljs.js2xml(rootElem, options);\n}\n\nfunction classToXmlInternal(\n  entity: any,\n  name: string | undefined,\n  entityConstructor: any,\n): xmljs.Element {\n  if ([String, Number, Boolean].includes(entityConstructor)) {\n    const text = entity === null ? '' : `${entity}`;\n\n    return {\n      type: 'element',\n      name: name!,\n      elements: [\n        {\n          type: 'text',\n          text,\n        },\n      ],\n    };\n  }\n\n  const meta = registry.get(entityConstructor);\n\n  if (!meta) {\n    throw errUnknownClass(entityConstructor);\n  }\n\n  const elemName = name || meta.entity.name;\n\n  if (!elemName) {\n    throw new Error(\n      `No XML name is specified for the class \"${entityConstructor?.name}\". Specify it with the @XmlEntity({ name: '...' }) decorator.`,\n    );\n  }\n\n  const children: xmljs.Element[] = [];\n\n  const attributes: xmljs.Attributes = {};\n\n  meta.properties.forEach((opts, classKey) => {\n    // Do not emit attribute if value is undefined,\n    if (entity[classKey] === undefined) {\n      return;\n    }\n\n    if (opts.attr) {\n      if (!opts.name) {\n        throw new Error(\n          `No name is specified for the property ${entityConstructor?.name}#${classKey}. Specify it with the @XmlProperty({ name: '...' }) decorator.`,\n        );\n      }\n\n      attributes[opts.name] =\n        entity[classKey] === null ? '' : `${entity[classKey]}`;\n    } else if (opts.chardata) {\n      children.push({\n        type: 'text',\n        text: entity[classKey] === null ? '' : `${entity[classKey]}`,\n      });\n    } else if (opts.array) {\n      if (entity[classKey] === null) {\n        return;\n      }\n\n      entity[classKey]?.forEach((e: any) => {\n        // Do not process null and undefined values in the array.\n        // When we impl support for primitive unions maybe this should change\n        if (!e) {\n          return;\n        }\n\n        // If it is a union then we can't guess required class out of it.\n        // In those cases users should give to the library actual class instances (aka new MyEntity({...}))\n        // so the library can guess the class type just by looking at the myEntity.constructor\n        const classConstructor = opts.union ? e.constructor : opts.type;\n        // The opts.name will be undefined if !!opts.union, but thats ok.\n        children.push(classToXmlInternal(e, opts.name, classConstructor));\n      });\n    } else if ([String, Number, Boolean].includes(opts.type as any)) {\n      if (!opts.name) {\n        throw new Error(\n          `No name is specified for property ${entityConstructor?.name}#${classKey}. Specify it with @XmlProperty({ name: '...' }) decorator.`,\n        );\n      }\n      children.push(classToXmlInternal(entity[classKey], opts.name, opts.type));\n    } else if (opts.union) {\n      // should work with primitive types also\n      const classConstructor = entity[classKey].constructor;\n\n      children.push(\n        classToXmlInternal(entity[classKey], undefined, classConstructor),\n      );\n    } else {\n      // If null then just skip this embedded element for the current impl\n      // TODO: maybe non array unions are borken\n      if (entity[classKey] !== null) {\n        children.push(\n          classToXmlInternal(\n            entity[classKey],\n            opts.name,\n            opts.union ? entity[classKey].constructor : opts.type,\n          ),\n        );\n      }\n    }\n  });\n\n  if (meta.entity.xmlns) {\n    attributes['xmlns'] = meta.entity.xmlns;\n  }\n\n  return {\n    type: 'element',\n    name: elemName,\n    attributes,\n    elements: children,\n  };\n}\n","import xmljs from 'xml-js';\nimport { registry } from './class-metadata-registry';\nimport type { AnyClass, XmlPrimitiveType, XmlType } from './types';\nimport { errUnknownClass } from './common';\n\nexport function xmlToClass<T extends AnyClass>(\n  xml: string,\n  _class: T,\n): InstanceType<T> {\n  const parsed = xmljs.xml2js(xml, {\n    compact: false,\n    alwaysArray: true,\n  }) as xmljs.Element;\n\n  const firstElement = parsed.elements?.[0];\n\n  if (!firstElement) {\n    throw new Error('No elements found in xml.');\n  }\n\n  return xmlToClassInternal(firstElement, _class);\n}\n\nfunction xmlToClassInternal(element: xmljs.Element, _class: any): any {\n  if ([String, Number, Boolean].includes(_class)) {\n    const text = getTextForElem(element);\n\n    return parsePrimitive(text, _class);\n  }\n\n  const metadatas = registry.get(_class);\n\n  if (!metadatas) {\n    throw new Error('Unknown class ' + _class);\n  }\n\n  const inst = new _class();\n\n  metadatas.properties.forEach((metadata, key) => {\n    if (metadata.attr) {\n      if (!metadata.name) {\n        throw new Error(\n          `No name is specified for attribute ${key}. Specify it with @XmlProperty({ name: '...' }) decorator.`,\n        );\n      }\n\n      const attr = element.attributes?.[metadata.name];\n\n      if (attr !== undefined && attr !== null) {\n        inst[key] = parsePrimitive(\n          attr,\n          metadata.type as XmlPrimitiveType | undefined,\n        );\n      } else {\n        // If the attribute property is undefined - it means\n        // that the attribute was not present in the xml.\n        inst[key] = undefined;\n      }\n    } else if (metadata.chardata) {\n      inst[key] = xmlToClassInternal(element, metadata.type);\n    } else if (metadata.array) {\n      if (metadata.union) {\n        // TODO: optimize and cache this map:\n        const tagNameToClassType: Map<string, any> = new Map();\n\n        metadata.union.forEach((classType) => {\n          const classTypeMetadata = registry.get(classType);\n\n          if (!classTypeMetadata) {\n            throw errUnknownClass(classType);\n          }\n\n          const tagName = classTypeMetadata.entity.name;\n\n          if (!tagName) {\n            throw new Error(\n              `No name is specified for ${classType}. Specify it with the @XmlEntity({ name: '...' }) decorator.`,\n            );\n          }\n\n          tagNameToClassType.set(tagName, classType);\n        });\n\n        const possibleTagNames = [...tagNameToClassType.keys()];\n\n        const resolvedValues: any[] = [];\n\n        element.elements?.forEach((el) => {\n          if (el.name && possibleTagNames.includes(el.name)) {\n            const classType = tagNameToClassType.get(el.name);\n\n            const entity = xmlToClassInternal(el, classType);\n\n            resolvedValues.push(entity);\n          }\n        });\n\n        inst[key] = resolvedValues;\n      } else {\n        const elems =\n          element.elements?.filter((e) => e.name === metadata.name) || [];\n\n        const resolvedValues: any[] = [];\n\n        elems.forEach((el) => {\n          const entity = xmlToClassInternal(el, metadata.type as XmlType);\n\n          resolvedValues.push(entity);\n        });\n\n        inst[key] = resolvedValues;\n      }\n    } else if (metadata.union) {\n      // TODO: optimize and cache this map:\n      const tagNameToClassType: Map<string, any> = new Map();\n\n      metadata.union.forEach((classType) => {\n        const classTypeMetadata = registry.get(classType);\n\n        if (!classTypeMetadata) {\n          throw errUnknownClass(classType);\n        }\n\n        const tagName = classTypeMetadata.entity.name;\n\n        if (!tagName) {\n          throw new Error(\n            `No name is specified for ${classType}. Specify it with the @XmlEntity({ name: '...' }) decorator.`,\n          );\n        }\n\n        tagNameToClassType.set(tagName, classType);\n      });\n\n      const matchingXmlElement = element.elements?.find((el) => {\n        return el.name && tagNameToClassType.has(el.name);\n      });\n\n      inst[key] = matchingXmlElement\n        ? xmlToClassInternal(\n            matchingXmlElement,\n            tagNameToClassType.get(matchingXmlElement.name!)!,\n          )\n        : undefined;\n    } else {\n      const el = element.elements?.find((el) => el.name === metadata.name);\n\n      if (el) {\n        const value: any = xmlToClassInternal(el, metadata.type);\n\n        inst[key] = value;\n      } else {\n        inst[key] = undefined;\n      }\n    }\n  });\n\n  return inst;\n}\n\nfunction getTextForElem(el: xmljs.Element): string {\n  return (el.elements?.find((e) => e.type === 'text')?.text as string) || '';\n}\n\nfunction parsePrimitive(\n  // Support numbers also\n  value: string | number | undefined,\n  classConstructor: XmlPrimitiveType | undefined,\n): number | string | boolean | null | undefined {\n  let result: number | string | boolean | null | undefined = undefined;\n\n  if (value === undefined) {\n    result = undefined;\n  } else {\n    const castToStr = `${value}`;\n\n    if (classConstructor === Number) {\n      result =\n        // parse empty strings to nulls when the specified type is Number\n        // bacause there is no convenient way to represent an empty string as a number,\n        // there is an idea to convert them to 0, but it's an implicit and non obvious behaviour.\n        // Maybe a better idea would be to convert them to NaN just as parseFloat does.\n        castToStr === '' ? null : castToStr ? parseFloat(castToStr) : undefined;\n    } else if (classConstructor === Boolean) {\n      result =\n        castToStr === '' ? null : castToStr ? castToStr === 'true' : undefined;\n    } else {\n      // classConstructor is String or any other type, then fallback to String:\n      // In case of the string dont cast empty strings to nulls\n      result = castToStr;\n    }\n  }\n\n  return result;\n}\n","import { registry } from './class-metadata-registry';\nimport { serializeUnionForLog } from './common';\nimport type {\n  XmlAttributeOptions,\n  XmlEntityOptions,\n  XmlPropertyOptions,\n} from './types';\n\n/**\n * Class decorator\n */\nexport function XmlEntity(opts?: XmlEntityOptions): ClassDecorator {\n  return (target: any): any => {\n    opts = opts || {};\n\n    opts.name = opts.name || target.name;\n\n    if (!opts.name) {\n      throw new Error(\n        `xml-class-transformer: Failed to get the element name for class ${target}. Specify it with @XmlEntity({ name: '...' }) decorator.`,\n      );\n    }\n\n    registry.setEntityOptions(target, opts);\n\n    return target;\n  };\n}\n\n/**\n * Class property decorator.\n */\nexport function XmlProperty(opts: XmlPropertyOptions): PropertyDecorator {\n  return propertyDecoratorFactory('XmlProperty', opts);\n}\n\n/**\n * Class property decorator.\n * For more details on options see {@link XmlAttributeOptions}\n *\n * @example\n * // a basic example\n * class SomeXmlElement {\n *   *XmlAttribute({ name: 'attributeName', type: String })\n *   attributeName: string;\n * }\n */\nexport function XmlAttribute(opts: XmlAttributeOptions): PropertyDecorator {\n  return propertyDecoratorFactory('XmlAttribute', {\n    ...opts,\n    attr: true,\n  });\n}\n\nfunction propertyDecoratorFactory(\n  decoratorName: 'XmlAttribute' | 'XmlProperty',\n  opts: XmlPropertyOptions,\n): PropertyDecorator {\n  return (target: { constructor: any }, propertyKey: string | symbol): void => {\n    if (typeof propertyKey !== 'string') {\n      // Dont support symbols for now\n      throw new TypeError(\n        `xml-class-transformer: Can't use @${decoratorName}({...}) decorator on a symbol property ` +\n          `at ${target.constructor.name}#${propertyKey.toString()}`,\n      );\n    }\n\n    if (opts.union && opts.type) {\n      throw new TypeError(\n        `xml-class-transformer: The \"union\" option is not compatible with the \"type\" option at ` +\n          `${target.constructor.name}#${propertyKey.toString()}.`,\n      );\n    }\n\n    if (!opts.union && !opts.type) {\n      throw new TypeError(\n        `xml-class-transformer: No \"type\" or \"union\" was specified for the ` +\n          `${target.constructor.name}#${propertyKey.toString()}. Add it to ` +\n          `the @${decoratorName}({...}) decorator.`,\n      );\n    }\n\n    if (opts.union && !opts.union.length) {\n      throw new TypeError(\n        `xml-class-transformer: The \"union\" option in @${decoratorName}({ ... }) can't be empty ` +\n          `at ${target.constructor.name}#${propertyKey.toString()}.`,\n      );\n    }\n\n    if (opts.union) {\n      if (opts.name) {\n        throw new TypeError(\n          `xml-class-transformer: The \"union\" option is not compatible with the \"name\" option at ` +\n            `${target.constructor.name}#${propertyKey.toString()}. ` +\n            `XML element names for the union memebers should be specified at ` +\n            `the union memeber classes.`,\n        );\n      }\n    } else {\n      opts.name = opts.name || propertyKey;\n    }\n\n    if (\n      opts.union &&\n      (opts.union.includes(String) ||\n        opts.union.includes(Number) ||\n        opts.union.includes(Boolean))\n    ) {\n      throw new TypeError(\n        `xml-class-transformer: unions of primitive types (String, Number or Boolean) are not supported. ` +\n          `Fix it in the decorator @${decoratorName}({ ` +\n          `union: ${serializeUnionForLog(opts.union)}, ... }) ` +\n          `at \"${target.constructor.name}#${propertyKey.toString()}\".`,\n      );\n    }\n\n    registry.setPropertyOptions(target.constructor, propertyKey, opts);\n  };\n}\n"],"names":["xmljs"],"mappings":"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"}