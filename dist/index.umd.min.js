/*!
 * xml-class-transformer v0.1.1
 * (c) Edgar Pogosyan
 * Released under the MIT License.
 */
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("xml-js")):"function"==typeof define&&define.amd?define(["exports","xml-js"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self)["xml-class-transformer"]={},e.xmljs)}(this,(function(e,t){"use strict";function n(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}var o=n(t);const r=new class{constructor(){this.registry=new Map}setEntityOptions(e,t){const n=this.registry.get(e);n?n.entity=t:this.registry.set(e,{entity:t,properties:new Map})}setPropertyOptions(e,t,n){const o=this.getOrCreate(e);if(n.name)for(const[r,i]of o.properties){if(i.name===n.name)throw new Error(`xml-class-transformer: can't use XML element name defined in { name: ${JSON.stringify(n.name)} } for ${e.name}#${t} since it's already used for ${e.name}#${r}. Change it to something else.`);if(n.chardata&&i.chardata)throw new Error(`xml-class-transformer: an XML element can have only one chardata property. Both ${e.name}#${t} and ${e.name}#${i.name} are defined as chardata, which is not valid.`)}o.properties.set(t,n)}getOrCreate(e){const t=this.registry.get(e);if(t)return t;{const t={entity:{name:null==e?void 0:e.name},properties:new Map};return this.registry.set(e,t),t}}get(e){return this.registry.get(e)}};function i(e){return new Error(`Class "${e}" not found. Make sure there is a @XmlEntity({...}) decorator on it, or @XmlProperty({...}) decorator on its properties.`)}function s(e,t,n){if([String,Number,Boolean].includes(n)){return{type:"element",name:t,elements:[{type:"text",text:null===e?"":`${e}`}]}}const o=r.get(n);if(!o)throw i(n);const a=t||o.entity.name;if(!a)throw new Error(`No XML name is specified for the class "${null==n?void 0:n.name}". Specify it with the @XmlEntity({ name: '...' }) decorator.`);const l=[],c={};return o.properties.forEach(((t,o)=>{var r;if(void 0!==e[o])if(t.attr){if(!t.name)throw new Error(`No name is specified for the property ${null==n?void 0:n.name}#${o}. Specify it with the @XmlProperty({ name: '...' }) decorator.`);c[t.name]=null===e[o]?"":`${e[o]}`}else if(t.chardata)l.push({type:"text",text:null===e[o]?"":`${e[o]}`});else if(t.array){if(null===e[o])return;null===(r=e[o])||void 0===r||r.forEach((e=>{if(!e)return;const n=t.union?e.constructor:t.type;l.push(s(e,t.name,n))}))}else if([String,Number,Boolean].includes(t.type)){if(!t.name)throw new Error(`No name is specified for property ${null==n?void 0:n.name}#${o}. Specify it with @XmlProperty({ name: '...' }) decorator.`);l.push(s(e[o],t.name,t.type))}else if(t.union){const t=e[o].constructor;l.push(s(e[o],void 0,t))}else null!==e[o]&&l.push(s(e[o],t.name,t.union?e[o].constructor:t.type))})),o.entity.xmlns&&(c.xmlns=o.entity.xmlns),{type:"element",name:a,attributes:c,elements:l}}function a(e,t){if([String,Number,Boolean].includes(t)){return l((null===(o=null===(n=e.elements)||void 0===n?void 0:n.find((e=>"text"===e.type)))||void 0===o?void 0:o.text)||"",t)}var n,o;const s=r.get(t);if(!s)throw new Error("Unknown class "+t);const c=new t;return s.properties.forEach(((t,n)=>{var o,s,m,u,f;if(t.attr){if(!t.name)throw new Error(`No name is specified for attribute ${n}. Specify it with @XmlProperty({ name: '...' }) decorator.`);const r=null===(o=e.attributes)||void 0===o?void 0:o[t.name];c[n]=null!=r?l(r,t.type):void 0}else if(t.chardata)c[n]=a(e,t.type);else if(t.array)if(t.union){const o=new Map;t.union.forEach((e=>{const t=r.get(e);if(!t)throw i(e);const n=t.entity.name;if(!n)throw new Error(`No name is specified for ${e}. Specify it with the @XmlEntity({ name: '...' }) decorator.`);o.set(n,e)}));const l=[...o.keys()],m=[];null===(s=e.elements)||void 0===s||s.forEach((e=>{if(e.name&&l.includes(e.name)){const t=a(e,o.get(e.name));m.push(t)}})),c[n]=m}else{const o=(null===(m=e.elements)||void 0===m?void 0:m.filter((e=>e.name===t.name)))||[],r=[];o.forEach((e=>{const n=a(e,t.type);r.push(n)})),c[n]=r}else if(t.union){const o=new Map;t.union.forEach((e=>{const t=r.get(e);if(!t)throw i(e);const n=t.entity.name;if(!n)throw new Error(`No name is specified for ${e}. Specify it with the @XmlEntity({ name: '...' }) decorator.`);o.set(n,e)}));const s=null===(u=e.elements)||void 0===u?void 0:u.find((e=>e.name&&o.has(e.name)));c[n]=s?a(s,o.get(s.name)):void 0}else{const o=null===(f=e.elements)||void 0===f?void 0:f.find((e=>e.name===t.name));if(o){const e=a(o,t.type);c[n]=e}else c[n]=void 0}})),c}function l(e,t){let n;if(void 0===e)n=void 0;else{const o=`${e}`;n=t===Number?""===o?null:o?parseFloat(o):void 0:t===Boolean?""===o?null:o?"true"===o:void 0:o}return n}e.XmlEntity=function(e){return t=>{if((e=e||{}).name=e.name||t.name,!e.name)throw new Error(`xml-class-transformer: Failed to get the element name for class ${t}. Specify it with @XmlEntity({ name: '...' }) decorator.`);return r.setEntityOptions(t,e),t}},e.XmlProperty=function(e){return function(e,t){return(n,o)=>{if("string"!=typeof o)throw new TypeError(`xml-class-transformer: Can't use @${e}({...}) decorator on a symbol property at ${n.constructor.name}#${o.toString()}`);if(t.union&&t.type)throw new TypeError(`xml-class-transformer: The "union" option is not compatible with the "type" option at ${n.constructor.name}#${o.toString()}.`);if(!t.union&&!t.type)throw new TypeError(`xml-class-transformer: No "type" or "union" was specified for the ${n.constructor.name}#${o.toString()}. Add it to the @${e}({...}) decorator.`);if(t.union&&!t.union.length)throw new TypeError(`xml-class-transformer: The "union" option in @${e}({ ... }) can't be empty at ${n.constructor.name}#${o.toString()}.`);if(t.union){if(t.name)throw new TypeError(`xml-class-transformer: The "union" option is not compatible with the "name" option at ${n.constructor.name}#${o.toString()}. XML element names for the union memebers should be specified at the union memeber classes.`)}else t.name=t.name||o;if(t.union&&(t.union.includes(String)||t.union.includes(Number)||t.union.includes(Boolean)))throw new TypeError(`xml-class-transformer: unions of primitive types (String, Number or Boolean) are not supported. Fix it in the decorator @${e}({ union: ${i=t.union,"["+i.map((e=>null===e?"null":void 0===e?"undefined":e.name)).join(", ")+"]"}, ... }) at "${n.constructor.name}#${o.toString()}".`);var i;r.setPropertyOptions(n.constructor,o,t)}}("XmlProperty",e)},e.classToXml=function(e,t){const n={elements:[s(e,"",e.constructor)]};return!1!==(null==t?void 0:t.declaration)&&("object"==typeof(null==t?void 0:t.declaration)&&null!==(null==t?void 0:t.declaration)?n.declaration=t.declaration:n.declaration={attributes:{version:"1.0",encoding:"UTF-8"}}),o.default.js2xml(n,t)},e.xmlToClass=function(e,t){var n;const r=null===(n=o.default.xml2js(e,{compact:!1,alwaysArray:!0}).elements)||void 0===n?void 0:n[0];if(!r)throw new Error("No elements found in xml.");return a(r,t)},Object.defineProperty(e,"__esModule",{value:!0})}));
//# sourceMappingURL=index.umd.min.js.map
