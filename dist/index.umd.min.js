/*!
 * xml-class-transformer v3.0.0
 * (c) Edgar Pogosyan
 * Released under the MIT License.
 */
!function(e,n){"object"==typeof exports&&"undefined"!=typeof module?n(exports,require("xml-js-v2")):"function"==typeof define&&define.amd?define(["exports","xml-js-v2"],n):n((e="undefined"!=typeof globalThis?globalThis:e||self)["xml-class-transformer"]={},e.xmljs)}(this,(function(e,n){"use strict";function t(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}var r=t(n);const o=new class{marshal(e){if(void 0!==e)return null===e?"":`${e}`}unmarshal(e){if(void 0===e)return;const n=`${e}`;return""===n?null:n?parseFloat(n):void 0}},i=new class{marshal(e){if(void 0!==e)return null===e?"":`${e}`}unmarshal(e){if(void 0===e)return;const n=`${e}`;return""===n?null:n?BigInt(n):void 0}},s=new class{marshal(e){if(void 0!==e)return null===e?"":`${e}`}unmarshal(e){if(void 0!==e)return`${e}`}},a=new class{marshal(e){if(void 0!==e)return null===e?"":`${e}`}unmarshal(e){if(void 0===e)return;const n=`${e}`;return""===n?null:n?"true"===n:void 0}},l=new class{marshal(e){if(void 0!==e)return null===e?"":e.toISOString()}unmarshal(e){if(void 0!==e)return""===e?null:new Date(e)}};function m(e){return new Error(`xml-class-transformer: class "${e}" not found. Make sure there is a @XmlElem({...}) decorator on it, or XmlChildElem, XmlAttribute, XmlChardata or XmlComments decorator on its properties.`)}function c(e){return new Error(`xml-class-transformer: no XML name is specified for ${null==e?void 0:e.name}. Specify it with the @XmlElem({ name: '...' }) decorator.`)}function u(e){return e===String||e===Number||e===BigInt||e===Boolean||e===Date}function f(e){switch(e){case String:return s;case Number:return o;case BigInt:return i;case Boolean:return a;case Date:return l}throw new Error("unknown primitive type "+e)}const p=new class{constructor(){this.registry=new Map}setEntityOptions(e,n){const t=this.registry.get(e);t?t.entity=n:this.registry.set(e,{entity:n,properties:new Map})}setPropertyOptions(e,n,t){const r=this.getOrCreate(e);if(t.comments)for(const[t,o]of r.properties)if(o.comments)throw new Error(`xml-class-transformer: only one @XmlComment() decorator is allowed per class. Can not define @XmlComment() decorator for  ${e.name}#${n} since it's already used for ${e.name}#${t}.`);if(t.name)for(const[o,i]of r.properties){if(i.name===t.name)throw new Error(`xml-class-transformer: can't use XML element name defined in { name: ${JSON.stringify(t.name)} } for ${e.name}#${n} since it's already used for ${e.name}#${o}. Change it to something else.`);if(t.chardata&&i.chardata)throw new Error(`xml-class-transformer: an XML element can have only one chardata property. Both ${e.name}#${n} and ${e.name}#${i.name} are defined as chardata, which is not valid.`)}r.properties.set(n,t)}getOrCreate(e){const n=this.registry.get(e);if(n)return n;{const n={entity:{name:null==e?void 0:e.name},properties:new Map};return this.registry.set(e,n),n}}get(e){return this.registry.get(e)}resolveUnionComponents(e){const n=new Map;for(const t of e){const e=p.get(t);if(!e)throw m(t);const r=e.entity.name;if(!r)throw c(t);n.set(r,t)}return n}};function h(e,n,t){if(u(t))return d(e,n,t);const r=p.get(t);if(!r)throw m(t);const o=n||r.entity.name;if(!o)throw c(t);const i=[],s={};for(const[n,o]of r.properties)y(t,e,o,n,i,s);return r.entity.xmlns&&(s.xmlns=r.entity.xmlns),{type:"element",name:o,attributes:s,elements:i}}function d(e,n,t){const r=f(t).marshal(e);return void 0===r?{}:{type:"element",name:n,elements:[{type:"text",text:r}]}}function y(e,n,t,r,o,i){t.comments?function(e,n,t){if(Array.isArray(e[n]))for(const r of e[n])t.push({type:"comment",comment:null==r?"":`${r}`})}(n,r,o):t.attr?function(e,n,t,r,o){if(!t.name)throw new Error(`xml-class-transformer: no name is specified for the property ${null==e?void 0:e.name}#${r}. Specify it with the @XmlAttribute({ name: '...' }) decorator.`);const i=w(n[r],t);if(void 0===i)return;o[t.name]=`${i}`}(e,n,t,r,i):t.chardata?function(e,n,t,r){const o=w(e[t],n);if(void 0===o)return;r.push({type:"text",text:o})}(n,t,r,o):t.array?function(e,n,t,r){if(null===e[t]||void 0===e[t])return;for(const o of e[t])if(n.marshaller||n.isPrimitiveType()){if(void 0===w(o,n))continue;r.push(d(o,n.name,String))}else{if(null==o)continue;const e=n.union?o.constructor:n.type();r.push(h(o,n.name,e))}}(n,t,r,o):t.marshaller||t.isPrimitiveType()?function(e,n,t,r,o){if(!t.name)throw new Error(`xml-class-transformer: no name is specified for property ${null==e?void 0:e.name}#${r}. Specify it with @XmlChildElem({ name: '...' }) decorator.`);const i=w(n[r],t);if(void 0===i)return;o.push(d(i,t.name,String))}(e,n,t,r,o):t.union?function(e,n,t){const r=e[n].constructor;t.push(h(e[n],void 0,r))}(n,r,o):function(e,n,t,r){void 0!==e[t]&&null!==e[t]&&r.push(h(e[t],n.name,n.type()))}(n,t,r,o)}function w(e,n){let t=e;if(n.marshaller)t=n.marshaller.marshal(e);else if(n.type){const r=n.type();u(r)&&(t=f(r).marshal(e))}return t}function v(e,n){if(u(n)){return function(e,n){const t=n?f(n):s,r="number"==typeof e?`${e}`:e;return t.unmarshal(r)}(g(e),n)}const t=p.get(n);if(!t)throw new Error("Unknown class "+n);const r=new n;for(const[n,o]of t.properties)$(e,o,n,r);return r}function $(e,n,t,r){n.comments?function(e,n,t){const r=[];for(const n of e.elements||[])"comment"===n.type&&r.push(n.comment||"");t[n]=r}(e,t,r):n.attr?function(e,n,t,r){var o;if(!t.name)throw new Error(`xml-class-transformer: no name is specified for attribute ${n}. Specify it with @XmlAttribute({ name: '...' }) decorator.`);let i=null===(o=e.attributes)||void 0===o?void 0:o[t.name];"number"==typeof i&&(i=`${i}`);const s=x(i,t);r[n]=s}(e,t,n,r):n.chardata?function(e,n,t,r){const o=g(e),i=x(o,t);r[n]=i}(e,t,n,r):n.array?function(e,n,t,r){var o;if(t.union){const o=p.resolveUnionComponents(t.union()),i=[];for(const n of e.elements||[])if(n.name&&o.has(n.name)){const e=v(n,o.get(n.name));i.push(e)}r[n]=i}else{const i=(null===(o=e.elements)||void 0===o?void 0:o.filter((e=>e.name===t.name)))||[],s=[];for(const e of i){const n=v(e,t.type());s.push(n)}r[n]=s}}(e,t,n,r):n.union?function(e,n,t,r){var o;const i=p.resolveUnionComponents(t.union()),s=null===(o=e.elements)||void 0===o?void 0:o.find((e=>!!e.name&&i.has(e.name)));r[n]=s?v(s,i.get(s.name)):void 0}(e,t,n,r):function(e,n,t,r){var o;const i=null===(o=e.elements)||void 0===o?void 0:o.find((e=>e.name===t.name));if(t.marshaller||t.isPrimitiveType()){const e=x(i?g(i):void 0,t);r[n]=e}else r[n]=i?v(i,t.type()):void 0}(e,t,n,r)}function g(e){let n="";for(const t of e.elements||[])"text"===t.type&&t.text&&(n+=t.text||"");return n}function x(e,n){let t=e;if(n.marshaller)t=n.marshaller.unmarshal(e);else if(n.type){const r=n.type();u(r)&&(t=f(r).unmarshal(e))}return t}class b{}class E extends b{constructor(e){super(),Object.assign(this,e)}isPrimitiveType(){return!!this.type&&u(this.type())}}function X(e,n){return(t,r)=>{if("string"!=typeof r)throw new TypeError(`xml-class-transformer: Can't use @${e}({...}) decorator on a symbol property at ${t.constructor.name}#${r.toString()}`);if(!n.union&&!n.type&&!n.marshaller)throw new TypeError(`xml-class-transformer: No "type", "union" or "marshaller" was specified for the ${t.constructor.name}#${r.toString()}. Add it to the @${e}({...}) decorator.`);if(n.union&&n.type||n.union&&n.marshaller||n.type&&n.marshaller)throw new TypeError(`xml-class-transformer: The "union", "type" or "marshaller" options are not compatible with each other at ${t.constructor.name}#${r.toString()}. You can specify only one of them.`);if(n.union&&!n.union().length)throw new TypeError(`xml-class-transformer: The "union" option in @${e}({ ... }) can't be empty at ${t.constructor.name}#${r.toString()}. Either remove the "union" option or provide it with at least one type.`);if(n.union){if(n.name)throw new TypeError(`xml-class-transformer: The "union" option is not compatible with the "name" option at ${t.constructor.name}#${r.toString()}. XML element names for the union members should be specified at the union member classes.`)}else n.name=n.name||r;if(n.union){const i=n.union();if(i.find((e=>u(e))))throw new TypeError(`xml-class-transformer: unions of primitive types (String, Number, Boolean, BigInt or Date) are not supported. Fix it in the decorator @${e}({ union: ${o=i,"["+o.map((e=>{var n;return null!==(n=null==e?void 0:e.name)&&void 0!==n?n:`${o}`})).join(", ")+"]"}, ... }) at "${t.constructor.name}#${r.toString()}".`)}var o;p.setPropertyOptions(t.constructor,r,n)}}e.XmlAttribute=function(e){return X("XmlAttribute",new E(Object.assign(Object.assign({},e),{attr:!0})))},e.XmlChardata=function(e){return X("XmlChardata",new E(Object.assign(Object.assign({},e),{chardata:!0})))},e.XmlChildElem=function(e){return X("XmlChildElem",new E(e))},e.XmlComments=function(){return(e,n)=>{if("string"!=typeof n)throw new TypeError(`xml-class-transformer: Can't use @XmlComments({...}) decorator on a symbol property at ${e.constructor.name}#${n.toString()}`);p.setPropertyOptions(e.constructor,n,new E({comments:!0}))}},e.XmlElem=function(e){return n=>{if((e=e||{}).name=e.name||n.name,!e.name)throw c(n);return p.setEntityOptions(n,e),n}},e.classToXml=function(e,n){const t={elements:[h(e,"",e.constructor)]};return!1!==(null==n?void 0:n.declaration)&&("object"==typeof(null==n?void 0:n.declaration)&&null!==(null==n?void 0:n.declaration)?t.declaration=n.declaration:t.declaration={attributes:{version:"1.0",encoding:"UTF-8"}}),r.default.js2xml(t,n)},e.xmlToClass=function(e,n,t){var o;const i=null===(o=r.default.xml2js(e,Object.assign(Object.assign({},t),{compact:!1,alwaysArray:!0})).elements)||void 0===o?void 0:o[0];if(!i)throw new Error("No elements found in xml.");return v(i,n)},Object.defineProperty(e,"__esModule",{value:!0})}));
