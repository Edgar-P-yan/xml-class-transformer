/*!
 * xml-class-transformer v2.3.0
 * (c) Edgar Pogosyan
 * Released under the MIT License.
 */
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("xml-js-v2")):"function"==typeof define&&define.amd?define(["exports","xml-js-v2"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self)["xml-class-transformer"]={},e.xmljs)}(this,(function(e,t){"use strict";function n(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}var r=n(t);const o=new class{constructor(){this.registry=new Map}setEntityOptions(e,t){const n=this.registry.get(e);n?n.entity=t:this.registry.set(e,{entity:t,properties:new Map})}setPropertyOptions(e,t,n){const r=this.getOrCreate(e);if(n.comments)for(const[n,o]of r.properties)if(o.comments)throw new Error(`xml-class-transformer: only one @XmlComment() decorator is allowed per class. Can not define @XmlComment() decorator for  ${e.name}#${t} since it's already used for ${e.name}#${n}.`);if(n.name)for(const[o,i]of r.properties){if(i.name===n.name)throw new Error(`xml-class-transformer: can't use XML element name defined in { name: ${JSON.stringify(n.name)} } for ${e.name}#${t} since it's already used for ${e.name}#${o}. Change it to something else.`);if(n.chardata&&i.chardata)throw new Error(`xml-class-transformer: an XML element can have only one chardata property. Both ${e.name}#${t} and ${e.name}#${i.name} are defined as chardata, which is not valid.`)}r.properties.set(t,n)}getOrCreate(e){const t=this.registry.get(e);if(t)return t;{const t={entity:{name:null==e?void 0:e.name},properties:new Map};return this.registry.set(e,t),t}}get(e){return this.registry.get(e)}};function i(e){return new Error(`xml-class-transformer: class "${e}" not found. Make sure there is a @XmlElem({...}) decorator on it, or XmlChildElem, XmlAttribute, XmlChardata or XmlComments decorator on its properties.`)}function s(e){return e===String||e===Number||e===BigInt||e===Boolean}function a(e,t,n){if(s(n)){return{type:"element",name:t,elements:[{type:"text",text:null===e?"":`${e}`}]}}const r=o.get(n);if(!r)throw i(n);const l=t||r.entity.name;if(!l)throw new Error(`xml-class-transformer: no XML name is specified for the class "${null==n?void 0:n.name}". Specify it with the @XmlElem({ name: '...' }) decorator.`);const m=[],c={};return r.properties.forEach(((t,r)=>{var o;if(void 0!==e[r])if(t.comments){if(Array.isArray(e[r]))for(const t of e[r])m.push({type:"comment",comment:null==t?"":`${t}`})}else if(t.attr){if(!t.name)throw new Error(`xml-class-transformer: no name is specified for the property ${null==n?void 0:n.name}#${r}. Specify it with the @XmlAttribute({ name: '...' }) decorator.`);c[t.name]=null===e[r]?"":`${e[r]}`}else if(t.chardata)m.push({type:"text",text:null===e[r]?"":`${e[r]}`});else if(t.array){if(null===e[r])return;null===(o=e[r])||void 0===o||o.forEach((e=>{if(!e)return;const n=t.union?e.constructor:t.type();m.push(a(e,t.name,n))}))}else if(t.type&&s(t.type())){if(!t.name)throw new Error(`xml-class-transformer: no name is specified for property ${null==n?void 0:n.name}#${r}. Specify it with @XmlChildElem({ name: '...' }) decorator.`);m.push(a(e[r],t.name,t.type()))}else if(t.union){const t=e[r].constructor;m.push(a(e[r],void 0,t))}else null!==e[r]&&m.push(a(e[r],t.name,t.union?e[r].constructor:t.type()))})),r.entity.xmlns&&(c.xmlns=r.entity.xmlns),{type:"element",name:l,attributes:c,elements:m}}function l(e,t){if(s(t)){return m(function(e){let t="";for(const n of e.elements||[])"text"===n.type&&n.text&&(t+=n.text||"");return t}(e),t)}const n=o.get(t);if(!n)throw new Error("Unknown class "+t);const r=new t;return n.properties.forEach(((t,n)=>{var s,a,c,f,u;if(t.comments){const t=[];for(const n of e.elements||[])"comment"===n.type&&t.push(n.comment||"");r[n]=t}else if(t.attr){if(!t.name)throw new Error(`xml-class-transformer: no name is specified for attribute ${n}. Specify it with @XmlAttribute({ name: '...' }) decorator.`);const o=null===(s=e.attributes)||void 0===s?void 0:s[t.name];r[n]=null!=o?m(o,t.type()):void 0}else if(t.chardata)r[n]=l(e,t.type());else if(t.array)if(t.union){const s=new Map;t.union().forEach((e=>{const t=o.get(e);if(!t)throw i(e);const n=t.entity.name;if(!n)throw new Error(`xml-class-transformer: no name is specified for ${e}. Specify it with the @XmlElem({ name: '...' }) decorator.`);s.set(n,e)}));const m=[...s.keys()],c=[];null===(a=e.elements)||void 0===a||a.forEach((e=>{if(e.name&&m.includes(e.name)){const t=l(e,s.get(e.name));c.push(t)}})),r[n]=c}else{const o=(null===(c=e.elements)||void 0===c?void 0:c.filter((e=>e.name===t.name)))||[],i=[];o.forEach((e=>{const n=l(e,t.type());i.push(n)})),r[n]=i}else if(t.union){const s=new Map;t.union().forEach((e=>{const t=o.get(e);if(!t)throw i(e);const n=t.entity.name;if(!n)throw new Error(`xml-class-transformer: no name is specified for ${e}. Specify it with the @XmlElem({ name: '...' }) decorator.`);s.set(n,e)}));const a=null===(f=e.elements)||void 0===f?void 0:f.find((e=>e.name&&s.has(e.name)));r[n]=a?l(a,s.get(a.name)):void 0}else{const o=null===(u=e.elements)||void 0===u?void 0:u.find((e=>e.name===t.name));if(o){const e=l(o,t.type());r[n]=e}else r[n]=void 0}})),r}function m(e,t){let n;if(void 0===e)n=void 0;else{const r=`${e}`;n=t===Number?""===r?null:parseFloat(r):t===BigInt?""===r?null:BigInt(r):t===Boolean?""===r?null:"true"===r:r}return n}function c(e,t){return(n,r)=>{if("string"!=typeof r)throw new TypeError(`xml-class-transformer: Can't use @${e}({...}) decorator on a symbol property at ${n.constructor.name}#${r.toString()}`);if(t.union&&t.type)throw new TypeError(`xml-class-transformer: The "union" option is not compatible with the "type" option at ${n.constructor.name}#${r.toString()}.`);if(!t.union&&!t.type)throw new TypeError(`xml-class-transformer: No "type" or "union" was specified for the ${n.constructor.name}#${r.toString()}. Add it to the @${e}({...}) decorator.`);if(t.union&&!t.union().length)throw new TypeError(`xml-class-transformer: The "union" option in @${e}({ ... }) can't be empty at ${n.constructor.name}#${r.toString()}. Either remove the "union" option or provide it with at least one type.`);if(t.union){if(t.name)throw new TypeError(`xml-class-transformer: The "union" option is not compatible with the "name" option at ${n.constructor.name}#${r.toString()}. XML element names for the union members should be specified at the union member classes.`)}else t.name=t.name||r;if(t.union){const o=t.union();if(o.find((e=>s(e))))throw new TypeError(`xml-class-transformer: unions of primitive types (String, Number or Boolean) are not supported. Fix it in the decorator @${e}({ union: ${i=o,"["+i.map((e=>{var t;return null!==(t=null==e?void 0:e.name)&&void 0!==t?t:`${i}`})).join(", ")+"]"}, ... }) at "${n.constructor.name}#${r.toString()}".`)}var i;o.setPropertyOptions(n.constructor,r,t)}}e.XmlAttribute=function(e){return c("XmlAttribute",Object.assign(Object.assign({},e),{attr:!0}))},e.XmlChardata=function(e){return c("XmlChardata",Object.assign(Object.assign({},e),{chardata:!0}))},e.XmlChildElem=function(e){return c("XmlChildElem",e)},e.XmlComments=function(){return(e,t)=>{if("string"!=typeof t)throw new TypeError(`xml-class-transformer: Can't use @XmlComments({...}) decorator on a symbol property at ${e.constructor.name}#${t.toString()}`);o.setPropertyOptions(e.constructor,t,{comments:!0})}},e.XmlElem=function(e){return t=>{if((e=e||{}).name=e.name||t.name,!e.name)throw new Error(`xml-class-transformer: Failed to get the element name for class ${t}. Specify it with @XmlElem({ name: '...' }) decorator.`);return o.setEntityOptions(t,e),t}},e.classToXml=function(e,t){const n={elements:[a(e,"",e.constructor)]};return!1!==(null==t?void 0:t.declaration)&&("object"==typeof(null==t?void 0:t.declaration)&&null!==(null==t?void 0:t.declaration)?n.declaration=t.declaration:n.declaration={attributes:{version:"1.0",encoding:"UTF-8"}}),r.default.js2xml(n,t)},e.xmlToClass=function(e,t){var n;const o=null===(n=r.default.xml2js(e,{compact:!1,alwaysArray:!0}).elements)||void 0===n?void 0:n[0];if(!o)throw new Error("No elements found in xml.");return l(o,t)},Object.defineProperty(e,"__esModule",{value:!0})}));
//# sourceMappingURL=index.umd.min.js.map
