/*!
 * xml-class-transformer v1.0.3
 * (c) Edgar Pogosyan
 * Released under the MIT License.
 */
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("xml-js")):"function"==typeof define&&define.amd?define(["exports","xml-js"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self)["xml-class-transformer"]={},e.xmljs)}(this,(function(e,t){"use strict";function n(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}var r=n(t);const o=new class{constructor(){this.registry=new Map}setEntityOptions(e,t){const n=this.registry.get(e);n?n.entity=t:this.registry.set(e,{entity:t,properties:new Map})}setPropertyOptions(e,t,n){const r=this.getOrCreate(e);if(n.name)for(const[o,i]of r.properties){if(i.name===n.name)throw new Error(`xml-class-transformer: can't use XML element name defined in { name: ${JSON.stringify(n.name)} } for ${e.name}#${t} since it's already used for ${e.name}#${o}. Change it to something else.`);if(n.chardata&&i.chardata)throw new Error(`xml-class-transformer: an XML element can have only one chardata property. Both ${e.name}#${t} and ${e.name}#${i.name} are defined as chardata, which is not valid.`)}r.properties.set(t,n)}getOrCreate(e){const t=this.registry.get(e);if(t)return t;{const t={entity:{name:null==e?void 0:e.name},properties:new Map};return this.registry.set(e,t),t}}get(e){return this.registry.get(e)}};function i(e){return new Error(`Class "${e}" not found. Make sure there is a @XmlEntity({...}) decorator on it, or @XmlProperty({...}) decorator on its properties.`)}function s(e){return e===String||e===Number||e===Boolean}function a(e,t,n){if(s(n)){return{type:"element",name:t,elements:[{type:"text",text:null===e?"":`${e}`}]}}const r=o.get(n);if(!r)throw i(n);const l=t||r.entity.name;if(!l)throw new Error(`No XML name is specified for the class "${null==n?void 0:n.name}". Specify it with the @XmlEntity({ name: '...' }) decorator.`);const c=[],m={};return r.properties.forEach(((t,r)=>{var o;if(void 0!==e[r])if(t.attr){if(!t.name)throw new Error(`No name is specified for the property ${null==n?void 0:n.name}#${r}. Specify it with the @XmlProperty({ name: '...' }) decorator.`);m[t.name]=null===e[r]?"":`${e[r]}`}else if(t.chardata)c.push({type:"text",text:null===e[r]?"":`${e[r]}`});else if(t.array){if(null===e[r])return;null===(o=e[r])||void 0===o||o.forEach((e=>{if(!e)return;const n=t.union?e.constructor:t.type();c.push(a(e,t.name,n))}))}else if(t.type&&s(t.type())){if(!t.name)throw new Error(`No name is specified for property ${null==n?void 0:n.name}#${r}. Specify it with @XmlProperty({ name: '...' }) decorator.`);c.push(a(e[r],t.name,t.type()))}else if(t.union){const t=e[r].constructor;c.push(a(e[r],void 0,t))}else null!==e[r]&&c.push(a(e[r],t.name,t.union?e[r].constructor:t.type()))})),r.entity.xmlns&&(m.xmlns=r.entity.xmlns),{type:"element",name:l,attributes:m,elements:c}}function l(e,t){if(s(t)){return c((null===(r=null===(n=e.elements)||void 0===n?void 0:n.find((e=>"text"===e.type)))||void 0===r?void 0:r.text)||"",t)}var n,r;const a=o.get(t);if(!a)throw new Error("Unknown class "+t);const m=new t;return a.properties.forEach(((t,n)=>{var r,s,a,u,f;if(t.attr){if(!t.name)throw new Error(`No name is specified for attribute ${n}. Specify it with @XmlProperty({ name: '...' }) decorator.`);const o=null===(r=e.attributes)||void 0===r?void 0:r[t.name];m[n]=null!=o?c(o,t.type()):void 0}else if(t.chardata)m[n]=l(e,t.type());else if(t.array)if(t.union){const r=new Map;t.union().forEach((e=>{const t=o.get(e);if(!t)throw i(e);const n=t.entity.name;if(!n)throw new Error(`No name is specified for ${e}. Specify it with the @XmlEntity({ name: '...' }) decorator.`);r.set(n,e)}));const a=[...r.keys()],c=[];null===(s=e.elements)||void 0===s||s.forEach((e=>{if(e.name&&a.includes(e.name)){const t=l(e,r.get(e.name));c.push(t)}})),m[n]=c}else{const r=(null===(a=e.elements)||void 0===a?void 0:a.filter((e=>e.name===t.name)))||[],o=[];r.forEach((e=>{const n=l(e,t.type());o.push(n)})),m[n]=o}else if(t.union){const r=new Map;t.union().forEach((e=>{const t=o.get(e);if(!t)throw i(e);const n=t.entity.name;if(!n)throw new Error(`No name is specified for ${e}. Specify it with the @XmlEntity({ name: '...' }) decorator.`);r.set(n,e)}));const s=null===(u=e.elements)||void 0===u?void 0:u.find((e=>e.name&&r.has(e.name)));m[n]=s?l(s,r.get(s.name)):void 0}else{const r=null===(f=e.elements)||void 0===f?void 0:f.find((e=>e.name===t.name));if(r){const e=l(r,t.type());m[n]=e}else m[n]=void 0}})),m}function c(e,t){let n;if(void 0===e)n=void 0;else{const r=`${e}`;n=t===Number?""===r?null:r?parseFloat(r):void 0:t===Boolean?""===r?null:r?"true"===r:void 0:r}return n}function m(e,t){return(n,r)=>{if("string"!=typeof r)throw new TypeError(`xml-class-transformer: Can't use @${e}({...}) decorator on a symbol property at ${n.constructor.name}#${r.toString()}`);if(t.union&&t.type)throw new TypeError(`xml-class-transformer: The "union" option is not compatible with the "type" option at ${n.constructor.name}#${r.toString()}.`);if(!t.union&&!t.type)throw new TypeError(`xml-class-transformer: No "type" or "union" was specified for the ${n.constructor.name}#${r.toString()}. Add it to the @${e}({...}) decorator.`);if(t.union&&!t.union().length)throw new TypeError(`xml-class-transformer: The "union" option in @${e}({ ... }) can't be empty at ${n.constructor.name}#${r.toString()}.`);if(t.union){if(t.name)throw new TypeError(`xml-class-transformer: The "union" option is not compatible with the "name" option at ${n.constructor.name}#${r.toString()}. XML element names for the union memebers should be specified at the union memeber classes.`)}else t.name=t.name||r;if(t.union&&(t.union().includes(String)||t.union().includes(Number)||t.union().includes(Boolean)))throw new TypeError(`xml-class-transformer: unions of primitive types (String, Number or Boolean) are not supported. Fix it in the decorator @${e}({ union: ${i=t.union(),"["+i.map((e=>null===e?"null":void 0===e?"undefined":e.name||`${i}`)).join(", ")+"]"}, ... }) at "${n.constructor.name}#${r.toString()}".`);var i;o.setPropertyOptions(n.constructor,r,t)}}e.XmlAttribute=function(e){return m("XmlAttribute",Object.assign(Object.assign({},e),{attr:!0}))},e.XmlEntity=function(e){return t=>{if((e=e||{}).name=e.name||t.name,!e.name)throw new Error(`xml-class-transformer: Failed to get the element name for class ${t}. Specify it with @XmlEntity({ name: '...' }) decorator.`);return o.setEntityOptions(t,e),t}},e.XmlProperty=function(e){return m("XmlProperty",e)},e.classToXml=function(e,t){const n={elements:[a(e,"",e.constructor)]};return!1!==(null==t?void 0:t.declaration)&&("object"==typeof(null==t?void 0:t.declaration)&&null!==(null==t?void 0:t.declaration)?n.declaration=t.declaration:n.declaration={attributes:{version:"1.0",encoding:"UTF-8"}}),r.default.js2xml(n,t)},e.xmlToClass=function(e,t){var n;const o=null===(n=r.default.xml2js(e,{compact:!1,alwaysArray:!0}).elements)||void 0===n?void 0:n[0];if(!o)throw new Error("No elements found in xml.");return l(o,t)},Object.defineProperty(e,"__esModule",{value:!0})}));
//# sourceMappingURL=index.umd.min.js.map
