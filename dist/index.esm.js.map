{"version":3,"file":"index.esm.js","sources":["../src/class-metadata-registry.ts","../src/common.ts","../src/transform-class-to-xml.ts","../src/transform-xml-to-class.ts","../src/decorators.ts"],"sourcesContent":["import type { XmlClass, XmlEntityOptions, XmlPropertyOptions } from './types';\n\ntype ClassMetadatas = {\n  properties: Map<string, XmlPropertyOptions>;\n  entity: XmlEntityOptions;\n};\n\nexport class ClassMetadataRegistry {\n  private registry = new Map<XmlClass, ClassMetadatas>();\n\n  setEntityOptions(clazz: XmlClass, opts: XmlEntityOptions): void {\n    const metadata = this.registry.get(clazz);\n\n    if (metadata) {\n      metadata.entity = opts;\n    } else {\n      this.registry.set(clazz, {\n        entity: opts,\n        properties: new Map(),\n      });\n    }\n  }\n\n  setPropertyOptions(\n    clazz: XmlClass,\n    propertyKey: string,\n    opts: XmlPropertyOptions,\n  ): void {\n    const metadata = this.getOrCreate(clazz);\n\n    if (opts.name) {\n      for (const [searchingPropKey, searchingOpts] of metadata.properties) {\n        if (searchingOpts.name === opts.name) {\n          throw new Error(\n            `xml-class-transformer: can't use XML element name defined in ` +\n              `{ name: ${JSON.stringify(opts.name)} } for ` +\n              `${clazz.name}#${propertyKey} since it's already used for ` +\n              `${clazz.name}#${searchingPropKey}. Change it to something else.`,\n          );\n        }\n\n        // TODO: maybe support multiple chardata for multiple child text nodes inside an xml element.\n        // each of those chardata properties whould match the text node at the same position as the property itself.\n        // The same goes for not yet implemented comments and cdata.\n        if (opts.chardata && searchingOpts.chardata) {\n          throw new Error(\n            `xml-class-transformer: an XML element can have only one chardata property. ` +\n              `Both ${clazz.name}#${propertyKey} and ${clazz.name}#${searchingOpts.name} ` +\n              `are defined as chardata, which is not valid.`,\n          );\n        }\n      }\n    }\n\n    metadata.properties.set(propertyKey, opts);\n  }\n\n  private getOrCreate(clazz: XmlClass): ClassMetadatas {\n    const existing = this.registry.get(clazz);\n    if (existing) {\n      return existing;\n    } else {\n      const newMetadatas: ClassMetadatas = {\n        entity: {\n          name: clazz?.name,\n        },\n        properties: new Map(),\n      };\n\n      this.registry.set(clazz, newMetadatas);\n\n      return newMetadatas;\n    }\n  }\n\n  get(clazz: XmlClass): ClassMetadatas | undefined {\n    return this.registry.get(clazz);\n  }\n}\n\nexport const registry = new ClassMetadataRegistry();\n","import { XmlPrimitiveType, XmlType } from './types';\n\nexport function errUnknownClass(classConstructor: any): Error {\n  return new Error(\n    `Class \"${classConstructor}\" not found. Make sure there is a @XmlEntity({...}) decorator on it, or @XmlProperty({...}) decorator on its properties.`,\n  );\n}\n\nexport function serializeUnionForLog(union: any[]): string {\n  return (\n    '[' +\n    union\n      .map((t) =>\n        t === null\n          ? 'null'\n          : t === undefined\n          ? 'undefined'\n          : t.name || `${union}`,\n      )\n      .join(', ') +\n    ']'\n  );\n}\n\nexport function isPrimitiveType(type: XmlType): type is XmlPrimitiveType {\n  return type === String || type === Number || type === Boolean;\n}\n","import xmljs from 'xml-js';\nimport { registry } from './class-metadata-registry';\nimport { ClassToXmlOptions, XmlType } from './types';\nimport { errUnknownClass, isPrimitiveType } from './common';\n\nexport function classToXml(entity: any, options?: ClassToXmlOptions): string {\n  const tree = classToXmlInternal(entity, '', entity.constructor);\n\n  const rootElem: xmljs.Element = { elements: [tree] };\n\n  if (options?.declaration !== false) {\n    if (\n      typeof options?.declaration === 'object' &&\n      options?.declaration !== null\n    ) {\n      rootElem.declaration = options.declaration;\n    } else {\n      rootElem.declaration = {\n        attributes: { version: '1.0', encoding: 'UTF-8' },\n      };\n    }\n  }\n\n  return xmljs.js2xml(rootElem, options);\n}\n\nfunction classToXmlInternal(\n  entity: any,\n  name: string | undefined,\n  entityConstructor: XmlType,\n): xmljs.Element {\n  if (isPrimitiveType(entityConstructor)) {\n    const text = entity === null ? '' : `${entity}`;\n\n    return {\n      type: 'element',\n      name: name!,\n      elements: [\n        {\n          type: 'text',\n          text,\n        },\n      ],\n    };\n  }\n\n  const meta = registry.get(entityConstructor);\n\n  if (!meta) {\n    throw errUnknownClass(entityConstructor);\n  }\n\n  const elemName = name || meta.entity.name;\n\n  if (!elemName) {\n    throw new Error(\n      `No XML name is specified for the class \"${entityConstructor?.name}\". Specify it with the @XmlEntity({ name: '...' }) decorator.`,\n    );\n  }\n\n  const children: xmljs.Element[] = [];\n\n  const attributes: xmljs.Attributes = {};\n\n  meta.properties.forEach((opts, classKey) => {\n    // Do not emit attribute if value is undefined,\n    if (entity[classKey] === undefined) {\n      return;\n    }\n\n    if (opts.attr) {\n      if (!opts.name) {\n        throw new Error(\n          `No name is specified for the property ${entityConstructor?.name}#${classKey}. Specify it with the @XmlProperty({ name: '...' }) decorator.`,\n        );\n      }\n\n      attributes[opts.name] =\n        entity[classKey] === null ? '' : `${entity[classKey]}`;\n    } else if (opts.chardata) {\n      children.push({\n        type: 'text',\n        text: entity[classKey] === null ? '' : `${entity[classKey]}`,\n      });\n    } else if (opts.array) {\n      if (entity[classKey] === null) {\n        return;\n      }\n\n      entity[classKey]?.forEach((e: any) => {\n        // Do not process null and undefined values in the array.\n        // When we impl support for primitive unions maybe this should change\n        if (!e) {\n          return;\n        }\n\n        // If it is a union then we can't guess required class out of it.\n        // In those cases users should give to the library actual class instances (aka new MyEntity({...}))\n        // so the library can guess the class type just by looking at the myEntity.constructor\n        const classConstructor = opts.union ? e.constructor : opts.type!();\n        // The opts.name will be undefined if !!opts.union, but thats ok.\n        children.push(classToXmlInternal(e, opts.name, classConstructor));\n      });\n    } else if (opts.type && isPrimitiveType(opts.type())) {\n      if (!opts.name) {\n        throw new Error(\n          `No name is specified for property ${entityConstructor?.name}#${classKey}. Specify it with @XmlProperty({ name: '...' }) decorator.`,\n        );\n      }\n      children.push(\n        classToXmlInternal(entity[classKey], opts.name, opts.type()),\n      );\n    } else if (opts.union) {\n      // should work with primitive types also\n      const classConstructor = entity[classKey].constructor;\n\n      children.push(\n        classToXmlInternal(entity[classKey], undefined, classConstructor),\n      );\n    } else {\n      // If null then just skip this embedded element for the current impl\n      // TODO: maybe non array unions are borken\n      if (entity[classKey] !== null) {\n        children.push(\n          classToXmlInternal(\n            entity[classKey],\n            opts.name,\n            opts.union ? entity[classKey].constructor : opts.type!(),\n          ),\n        );\n      }\n    }\n  });\n\n  if (meta.entity.xmlns) {\n    attributes['xmlns'] = meta.entity.xmlns;\n  }\n\n  return {\n    type: 'element',\n    name: elemName,\n    attributes,\n    elements: children,\n  };\n}\n","import xmljs from 'xml-js';\nimport { registry } from './class-metadata-registry';\nimport type { XmlClass, XmlPrimitiveType, XmlType } from './types';\nimport { errUnknownClass, isPrimitiveType } from './common';\n\nexport function xmlToClass<T extends XmlClass>(\n  xml: string,\n  _class: T,\n): InstanceType<T> {\n  const parsed = xmljs.xml2js(xml, {\n    compact: false,\n    alwaysArray: true,\n  }) as xmljs.Element;\n\n  const firstElement = parsed.elements?.[0];\n\n  if (!firstElement) {\n    throw new Error('No elements found in xml.');\n  }\n\n  return xmlToClassInternal(firstElement, _class);\n}\n\nfunction xmlToClassInternal(element: xmljs.Element, _class: XmlType): any {\n  if (isPrimitiveType(_class)) {\n    const text = getTextForElem(element);\n\n    return parsePrimitive(text, _class);\n  }\n\n  const metadatas = registry.get(_class);\n\n  if (!metadatas) {\n    throw new Error('Unknown class ' + _class);\n  }\n\n  const inst = new _class();\n\n  metadatas.properties.forEach((metadata, key) => {\n    if (metadata.attr) {\n      if (!metadata.name) {\n        throw new Error(\n          `No name is specified for attribute ${key}. Specify it with @XmlProperty({ name: '...' }) decorator.`,\n        );\n      }\n\n      const attr = element.attributes?.[metadata.name];\n\n      if (attr !== undefined && attr !== null) {\n        inst[key] = parsePrimitive(attr, metadata.type!() as XmlPrimitiveType);\n      } else {\n        // If the attribute property is undefined - it means\n        // that the attribute was not present in the xml.\n        inst[key] = undefined;\n      }\n    } else if (metadata.chardata) {\n      inst[key] = xmlToClassInternal(element, metadata.type!());\n    } else if (metadata.array) {\n      if (metadata.union) {\n        // TODO: optimize and cache this map:\n        const tagNameToClassType: Map<string, any> = new Map();\n\n        metadata.union().forEach((classType) => {\n          const classTypeMetadata = registry.get(classType);\n\n          if (!classTypeMetadata) {\n            throw errUnknownClass(classType);\n          }\n\n          const tagName = classTypeMetadata.entity.name;\n\n          if (!tagName) {\n            throw new Error(\n              `No name is specified for ${classType}. Specify it with the @XmlEntity({ name: '...' }) decorator.`,\n            );\n          }\n\n          tagNameToClassType.set(tagName, classType);\n        });\n\n        const possibleTagNames = [...tagNameToClassType.keys()];\n\n        const resolvedValues: any[] = [];\n\n        element.elements?.forEach((el) => {\n          if (el.name && possibleTagNames.includes(el.name)) {\n            const classType = tagNameToClassType.get(el.name);\n\n            const entity = xmlToClassInternal(el, classType);\n\n            resolvedValues.push(entity);\n          }\n        });\n\n        inst[key] = resolvedValues;\n      } else {\n        const elems =\n          element.elements?.filter((e) => e.name === metadata.name) || [];\n\n        const resolvedValues: any[] = [];\n\n        elems.forEach((el) => {\n          const entity = xmlToClassInternal(el, metadata.type!() as XmlType);\n\n          resolvedValues.push(entity);\n        });\n\n        inst[key] = resolvedValues;\n      }\n    } else if (metadata.union) {\n      // TODO: optimize and cache this map:\n      const tagNameToClassType: Map<string, any> = new Map();\n\n      metadata.union().forEach((classType) => {\n        const classTypeMetadata = registry.get(classType);\n\n        if (!classTypeMetadata) {\n          throw errUnknownClass(classType);\n        }\n\n        const tagName = classTypeMetadata.entity.name;\n\n        if (!tagName) {\n          throw new Error(\n            `No name is specified for ${classType}. Specify it with the @XmlEntity({ name: '...' }) decorator.`,\n          );\n        }\n\n        tagNameToClassType.set(tagName, classType);\n      });\n\n      const matchingXmlElement = element.elements?.find((el) => {\n        return el.name && tagNameToClassType.has(el.name);\n      });\n\n      inst[key] = matchingXmlElement\n        ? xmlToClassInternal(\n            matchingXmlElement,\n            tagNameToClassType.get(matchingXmlElement.name!)!,\n          )\n        : undefined;\n    } else {\n      const el = element.elements?.find((el) => el.name === metadata.name);\n\n      if (el) {\n        const value: any = xmlToClassInternal(el, metadata.type!());\n\n        inst[key] = value;\n      } else {\n        inst[key] = undefined;\n      }\n    }\n  });\n\n  return inst;\n}\n\nfunction getTextForElem(el: xmljs.Element): string {\n  return (el.elements?.find((e) => e.type === 'text')?.text as string) || '';\n}\n\nfunction parsePrimitive(\n  // Support numbers also\n  value: string | number | undefined,\n  classConstructor: XmlPrimitiveType | undefined,\n): number | string | boolean | null | undefined {\n  let result: number | string | boolean | null | undefined = undefined;\n\n  if (value === undefined) {\n    result = undefined;\n  } else {\n    const castToStr = `${value}`;\n\n    if (classConstructor === Number) {\n      result =\n        // parse empty strings to nulls when the specified type is Number\n        // bacause there is no convenient way to represent an empty string as a number,\n        // there is an idea to convert them to 0, but it's an implicit and non obvious behaviour.\n        // Maybe a better idea would be to convert them to NaN just as parseFloat does.\n        castToStr === '' ? null : castToStr ? parseFloat(castToStr) : undefined;\n    } else if (classConstructor === Boolean) {\n      result =\n        castToStr === '' ? null : castToStr ? castToStr === 'true' : undefined;\n    } else {\n      // classConstructor is String or any other type, then fallback to String:\n      // In case of the string dont cast empty strings to nulls\n      result = castToStr;\n    }\n  }\n\n  return result;\n}\n","import { registry } from './class-metadata-registry';\nimport { serializeUnionForLog } from './common';\nimport type {\n  XmlAttributeOptions,\n  XmlEntityOptions,\n  XmlPropertyOptions,\n} from './types';\n\n/**\n * Class decorator\n */\nexport function XmlEntity(opts?: XmlEntityOptions): ClassDecorator {\n  return (target: any): any => {\n    opts = opts || {};\n\n    opts.name = opts.name || target.name;\n\n    if (!opts.name) {\n      throw new Error(\n        `xml-class-transformer: Failed to get the element name for class ${target}. Specify it with @XmlEntity({ name: '...' }) decorator.`,\n      );\n    }\n\n    registry.setEntityOptions(target, opts);\n\n    return target;\n  };\n}\n\n/**\n * Class property decorator.\n */\nexport function XmlProperty(opts: XmlPropertyOptions): PropertyDecorator {\n  return propertyDecoratorFactory('XmlProperty', opts);\n}\n\n/**\n * Class property decorator.\n * For more details on options see {@link XmlAttributeOptions}\n *\n * @example\n * // a basic example\n * class SomeXmlElement {\n *   *XmlAttribute({ name: 'attributeName', type: () => String })\n *   attributeName: string;\n * }\n */\nexport function XmlAttribute(opts: XmlAttributeOptions): PropertyDecorator {\n  return propertyDecoratorFactory('XmlAttribute', {\n    ...opts,\n    attr: true,\n  });\n}\n\nfunction propertyDecoratorFactory(\n  decoratorName: 'XmlAttribute' | 'XmlProperty',\n  opts: XmlPropertyOptions,\n): PropertyDecorator {\n  return (target: { constructor: any }, propertyKey: string | symbol): void => {\n    if (typeof propertyKey !== 'string') {\n      // Dont support symbols for now\n      throw new TypeError(\n        `xml-class-transformer: Can't use @${decoratorName}({...}) decorator on a symbol property ` +\n          `at ${target.constructor.name}#${propertyKey.toString()}`,\n      );\n    }\n\n    if (opts.union && opts.type) {\n      throw new TypeError(\n        `xml-class-transformer: The \"union\" option is not compatible with the \"type\" option at ` +\n          `${target.constructor.name}#${propertyKey.toString()}.`,\n      );\n    }\n\n    if (!opts.union && !opts.type) {\n      throw new TypeError(\n        `xml-class-transformer: No \"type\" or \"union\" was specified for the ` +\n          `${target.constructor.name}#${propertyKey.toString()}. Add it to ` +\n          `the @${decoratorName}({...}) decorator.`,\n      );\n    }\n\n    // opts.union here can potentially return an array of undefineds\n    // in case if there are circular dependencies. But that's okay,\n    // because we only need to check that the array is not empty.\n    if (opts.union && !opts.union().length) {\n      throw new TypeError(\n        `xml-class-transformer: The \"union\" option in @${decoratorName}({ ... }) can't be empty ` +\n          `at ${target.constructor.name}#${propertyKey.toString()}.`,\n      );\n    }\n\n    if (opts.union) {\n      if (opts.name) {\n        throw new TypeError(\n          `xml-class-transformer: The \"union\" option is not compatible with the \"name\" option at ` +\n            `${target.constructor.name}#${propertyKey.toString()}. ` +\n            `XML element names for the union memebers should be specified at ` +\n            `the union memeber classes.`,\n        );\n      }\n    } else {\n      opts.name = opts.name || propertyKey;\n    }\n\n    if (\n      opts.union &&\n      // opts.union() can potentially return undefineds in case if there are circular dependencies.\n      // But the primitive values constructors (String, Number and Boolean) are always defined.\n      // So it's okay to check them like this:\n      (opts.union().includes(String) ||\n        opts.union().includes(Number) ||\n        opts.union().includes(Boolean))\n    ) {\n      throw new TypeError(\n        `xml-class-transformer: unions of primitive types (String, Number or Boolean) are not supported. ` +\n          `Fix it in the decorator @${decoratorName}({ ` +\n          `union: ${serializeUnionForLog(opts.union())}, ... }) ` +\n          `at \"${target.constructor.name}#${propertyKey.toString()}\".`,\n      );\n    }\n\n    registry.setPropertyOptions(target.constructor, propertyKey, opts);\n  };\n}\n"],"names":[],"mappings":"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"}