{"version":3,"file":"index.umd.min.js","sources":["../src/class-metadata-registry.ts","../src/common.ts","../src/transform-class-to-xml.ts","../src/transform-xml-to-class.ts","../src/decorators.ts"],"sourcesContent":["import { InternalXmlPropertyOptions } from './internal-types';\nimport type { XmlClass, XmlElemOptions } from './types';\n\ntype ClassMetadatas = {\n  properties: Map<string, InternalXmlPropertyOptions>;\n  entity: XmlElemOptions;\n};\n\nexport class ClassMetadataRegistry {\n  private registry = new Map<XmlClass, ClassMetadatas>();\n\n  setEntityOptions(xClass: XmlClass, opts: XmlElemOptions): void {\n    const metadata = this.registry.get(xClass);\n\n    if (metadata) {\n      metadata.entity = opts;\n    } else {\n      this.registry.set(xClass, {\n        entity: opts,\n        properties: new Map(),\n      });\n    }\n  }\n\n  setPropertyOptions(\n    xClass: XmlClass,\n    propertyKey: string,\n    opts: InternalXmlPropertyOptions,\n  ): void {\n    const metadata = this.getOrCreate(xClass);\n\n    if (opts.comments) {\n      for (const [searchingPropKey, searchingOpts] of metadata.properties) {\n        if (searchingOpts.comments) {\n          throw new Error(\n            `xml-class-transformer: only one @XmlComment() decorator is allowed per class. ` +\n              `Can not define @XmlComment() decorator for  ` +\n              `${xClass.name}#${propertyKey} since it's already used for ` +\n              `${xClass.name}#${searchingPropKey}.`,\n          );\n        }\n      }\n    }\n\n    if (opts.name) {\n      for (const [searchingPropKey, searchingOpts] of metadata.properties) {\n        if (searchingOpts.name === opts.name) {\n          throw new Error(\n            `xml-class-transformer: can't use XML element name defined in ` +\n              `{ name: ${JSON.stringify(opts.name)} } for ` +\n              `${xClass.name}#${propertyKey} since it's already used for ` +\n              `${xClass.name}#${searchingPropKey}. Change it to something else.`,\n          );\n        }\n\n        // TODO: maybe support multiple chardata for multiple child text nodes inside an xml element.\n        // each of those chardata properties whould match the text node at the same position as the property itself.\n        // The same goes for not yet implemented comments and cdata.\n        if (opts.chardata && searchingOpts.chardata) {\n          throw new Error(\n            `xml-class-transformer: an XML element can have only one chardata property. ` +\n              `Both ${xClass.name}#${propertyKey} and ${xClass.name}#${searchingOpts.name} ` +\n              `are defined as chardata, which is not valid.`,\n          );\n        }\n      }\n    }\n\n    metadata.properties.set(propertyKey, opts);\n  }\n\n  private getOrCreate(xClass: XmlClass): ClassMetadatas {\n    const existing = this.registry.get(xClass);\n    if (existing) {\n      return existing;\n    } else {\n      const newMetadatas: ClassMetadatas = {\n        entity: {\n          name: xClass?.name,\n        },\n        properties: new Map(),\n      };\n\n      this.registry.set(xClass, newMetadatas);\n\n      return newMetadatas;\n    }\n  }\n\n  get(xClass: XmlClass): ClassMetadatas | undefined {\n    return this.registry.get(xClass);\n  }\n}\n\nexport const registry = new ClassMetadataRegistry();\n","import { XmlPrimitiveType, XmlType } from './types';\n\nexport function errUnknownClass(classConstructor: any): Error {\n  return new Error(\n    `xml-class-transformer: class \"${classConstructor}\" not found. Make sure there is a @XmlElem({...}) ` +\n      `decorator on it, or XmlChildElem, XmlAttribute, XmlChardata or XmlComments decorator on its properties.`,\n  );\n}\n\nexport function serializeUnionForLog(union: any[]): string {\n  return '[' + union.map((t) => t?.name ?? `${union}`).join(', ') + ']';\n}\n\nexport function isPrimitiveType(type: XmlType): type is XmlPrimitiveType {\n  return (\n    type === String || type === Number || type === BigInt || type === Boolean\n  );\n}\n","import xmljs from 'xml-js-v2';\nimport { registry } from './class-metadata-registry';\nimport { ClassToXmlOptions, XmlType } from './types';\nimport { errUnknownClass, isPrimitiveType } from './common';\n\nexport function classToXml(entity: any, options?: ClassToXmlOptions): string {\n  const tree = classToXmlInternal(entity, '', entity.constructor);\n\n  const rootElem: xmljs.Element = { elements: [tree] };\n\n  if (options?.declaration !== false) {\n    if (\n      typeof options?.declaration === 'object' &&\n      options?.declaration !== null\n    ) {\n      rootElem.declaration = options.declaration;\n    } else {\n      rootElem.declaration = {\n        attributes: { version: '1.0', encoding: 'UTF-8' },\n      };\n    }\n  }\n\n  return xmljs.js2xml(rootElem, options);\n}\n\nfunction classToXmlInternal(\n  entity: any,\n  name: string | undefined,\n  entityConstructor: XmlType,\n): xmljs.Element {\n  if (isPrimitiveType(entityConstructor)) {\n    const text = entity === null ? '' : `${entity}`;\n\n    return {\n      type: 'element',\n      name: name!,\n      elements: [\n        {\n          type: 'text',\n          text,\n        },\n      ],\n    };\n  }\n\n  const meta = registry.get(entityConstructor);\n\n  if (!meta) {\n    throw errUnknownClass(entityConstructor);\n  }\n\n  const elemName = name || meta.entity.name;\n\n  if (!elemName) {\n    throw new Error(\n      `xml-class-transformer: no XML name is specified for the class \"${entityConstructor?.name}\". Specify it with the @XmlElem({ name: '...' }) decorator.`,\n    );\n  }\n\n  const children: xmljs.Element[] = [];\n\n  const attributes: xmljs.Attributes = {};\n\n  meta.properties.forEach((opts, classKey) => {\n    // Do not emit attribute if value is undefined,\n    if (entity[classKey] === undefined) {\n      return;\n    }\n\n    if (opts.comments) {\n      if (Array.isArray(entity[classKey])) {\n        for (const comment of entity[classKey]) {\n          children.push({\n            type: 'comment',\n            comment:\n              comment === null || comment === undefined ? '' : `${comment}`,\n          });\n        }\n      }\n    } else if (opts.attr) {\n      if (!opts.name) {\n        throw new Error(\n          `xml-class-transformer: no name is specified for the property ${entityConstructor?.name}#${classKey}. Specify it with the @XmlAttribute({ name: '...' }) decorator.`,\n        );\n      }\n\n      attributes[opts.name] =\n        entity[classKey] === null ? '' : `${entity[classKey]}`;\n    } else if (opts.chardata) {\n      children.push({\n        type: 'text',\n        text: entity[classKey] === null ? '' : `${entity[classKey]}`,\n      });\n    } else if (opts.array) {\n      if (entity[classKey] === null) {\n        return;\n      }\n\n      entity[classKey]?.forEach((e: any) => {\n        // Do not process null and undefined values in the array.\n        // When we impl support for primitive unions maybe this should change\n        if (!e) {\n          return;\n        }\n\n        // If it is a union then we can't guess required class out of it.\n        // In those cases users should give to the library actual class instances (aka new MyEntity({...}))\n        // so the library can guess the class type just by looking at the myEntity.constructor\n        const classConstructor = opts.union ? e.constructor : opts.type!();\n        // The opts.name will be undefined if !!opts.union, but thats ok.\n        children.push(classToXmlInternal(e, opts.name, classConstructor));\n      });\n    } else if (opts.type && isPrimitiveType(opts.type())) {\n      if (!opts.name) {\n        throw new Error(\n          `xml-class-transformer: no name is specified for property ${entityConstructor?.name}#${classKey}. Specify it with @XmlChildElem({ name: '...' }) decorator.`,\n        );\n      }\n      children.push(\n        classToXmlInternal(entity[classKey], opts.name, opts.type()),\n      );\n    } else if (opts.union) {\n      // should work with primitive types also\n      const classConstructor = entity[classKey].constructor;\n\n      children.push(\n        classToXmlInternal(entity[classKey], undefined, classConstructor),\n      );\n    } else {\n      // If null then just skip this embedded element for the current impl\n      // TODO: maybe non array unions are borken\n      if (entity[classKey] !== null) {\n        children.push(\n          classToXmlInternal(\n            entity[classKey],\n            opts.name,\n            opts.union ? entity[classKey].constructor : opts.type!(),\n          ),\n        );\n      }\n    }\n  });\n\n  if (meta.entity.xmlns) {\n    attributes['xmlns'] = meta.entity.xmlns;\n  }\n\n  return {\n    type: 'element',\n    name: elemName,\n    attributes,\n    elements: children,\n  };\n}\n","import xmljs from 'xml-js-v2';\nimport { registry } from './class-metadata-registry';\nimport type { XmlClass, XmlPrimitiveType, XmlType } from './types';\nimport { errUnknownClass, isPrimitiveType } from './common';\n\nexport function xmlToClass<T extends XmlClass>(\n  xml: string,\n  _class: T,\n): InstanceType<T> {\n  const parsed = xmljs.xml2js(xml, {\n    compact: false,\n    alwaysArray: true,\n  }) as xmljs.Element;\n\n  const firstElement = parsed.elements?.[0];\n\n  if (!firstElement) {\n    throw new Error('No elements found in xml.');\n  }\n\n  return xmlToClassInternal(firstElement, _class);\n}\n\nfunction xmlToClassInternal(element: xmljs.Element, _class: XmlType): any {\n  if (isPrimitiveType(_class)) {\n    const text = getChardataFromElem(element);\n\n    return parsePrimitive(text, _class);\n  }\n\n  const metadatas = registry.get(_class);\n\n  if (!metadatas) {\n    throw new Error('Unknown class ' + _class);\n  }\n\n  const inst = new _class();\n\n  metadatas.properties.forEach((metadata, key) => {\n    if (metadata.comments) {\n      const commentsAccumulated: string[] = [];\n\n      for (const childElem of element.elements || []) {\n        if (childElem.type === 'comment') {\n          commentsAccumulated.push(childElem.comment || '');\n        }\n      }\n\n      inst[key] = commentsAccumulated;\n    } else if (metadata.attr) {\n      if (!metadata.name) {\n        throw new Error(\n          `xml-class-transformer: no name is specified for attribute ${key}. Specify it with @XmlAttribute({ name: '...' }) decorator.`,\n        );\n      }\n\n      const attr = element.attributes?.[metadata.name];\n\n      if (attr !== undefined && attr !== null) {\n        inst[key] = parsePrimitive(attr, metadata.type!() as XmlPrimitiveType);\n      } else {\n        // If the attribute property is undefined - it means\n        // that the attribute was not present in the xml.\n        inst[key] = undefined;\n      }\n    } else if (metadata.chardata) {\n      inst[key] = xmlToClassInternal(element, metadata.type!());\n    } else if (metadata.array) {\n      if (metadata.union) {\n        // TODO: optimize and cache this map:\n        const tagNameToClassType: Map<string, any> = new Map();\n\n        metadata.union().forEach((classType) => {\n          const classTypeMetadata = registry.get(classType);\n\n          if (!classTypeMetadata) {\n            throw errUnknownClass(classType);\n          }\n\n          const tagName = classTypeMetadata.entity.name;\n\n          if (!tagName) {\n            throw new Error(\n              `xml-class-transformer: no name is specified for ${classType}. Specify it with the @XmlElem({ name: '...' }) decorator.`,\n            );\n          }\n\n          tagNameToClassType.set(tagName, classType);\n        });\n\n        const possibleTagNames = [...tagNameToClassType.keys()];\n\n        const resolvedValues: any[] = [];\n\n        element.elements?.forEach((el) => {\n          if (el.name && possibleTagNames.includes(el.name)) {\n            const classType = tagNameToClassType.get(el.name);\n\n            const entity = xmlToClassInternal(el, classType);\n\n            resolvedValues.push(entity);\n          }\n        });\n\n        inst[key] = resolvedValues;\n      } else {\n        const elems =\n          element.elements?.filter((e) => e.name === metadata.name) || [];\n\n        const resolvedValues: any[] = [];\n\n        elems.forEach((el) => {\n          const entity = xmlToClassInternal(el, metadata.type!() as XmlType);\n\n          resolvedValues.push(entity);\n        });\n\n        inst[key] = resolvedValues;\n      }\n    } else if (metadata.union) {\n      // TODO: optimize and cache this map:\n      const tagNameToClassType: Map<string, any> = new Map();\n\n      metadata.union().forEach((classType) => {\n        const classTypeMetadata = registry.get(classType);\n\n        if (!classTypeMetadata) {\n          throw errUnknownClass(classType);\n        }\n\n        const tagName = classTypeMetadata.entity.name;\n\n        if (!tagName) {\n          throw new Error(\n            `xml-class-transformer: no name is specified for ${classType}. Specify it with the @XmlElem({ name: '...' }) decorator.`,\n          );\n        }\n\n        tagNameToClassType.set(tagName, classType);\n      });\n\n      const matchingXmlElement = element.elements?.find((el) => {\n        return el.name && tagNameToClassType.has(el.name);\n      });\n\n      inst[key] = matchingXmlElement\n        ? xmlToClassInternal(\n            matchingXmlElement,\n            tagNameToClassType.get(matchingXmlElement.name!)!,\n          )\n        : undefined;\n    } else {\n      const el = element.elements?.find((el) => el.name === metadata.name);\n\n      if (el) {\n        const value: any = xmlToClassInternal(el, metadata.type!());\n\n        inst[key] = value;\n      } else {\n        inst[key] = undefined;\n      }\n    }\n  });\n\n  return inst;\n}\n\nfunction getChardataFromElem(el: xmljs.Element): string {\n  let chardata = '';\n\n  for (const child of el.elements || []) {\n    if (child.type === 'text' && child.text) {\n      chardata += (child.text as string) || '';\n    }\n  }\n\n  return chardata;\n}\n\nfunction parsePrimitive(\n  // Support numbers also\n  value: string | number | undefined,\n  classConstructor: XmlPrimitiveType | undefined,\n): string | number | bigint | boolean | null | undefined {\n  let result: string | number | bigint | boolean | null | undefined = undefined;\n\n  if (value === undefined) {\n    result = undefined;\n  } else {\n    const castToStr = `${value}`;\n\n    if (classConstructor === Number) {\n      result =\n        // parse empty strings to nulls when the specified type is Number\n        // bacause there is no convenient way to represent an empty string as a number,\n        // there is an idea to convert them to 0, but it's an implicit and non obvious behaviour.\n        // Maybe a better idea would be to convert them to NaN just as parseFloat does.\n        castToStr === '' ? null : parseFloat(castToStr);\n    } else if (classConstructor === BigInt) {\n      result = castToStr === '' ? null : BigInt(castToStr);\n    } else if (classConstructor === Boolean) {\n      result = castToStr === '' ? null : castToStr === 'true';\n    } else {\n      // classConstructor is String or any other type, then fallback to String:\n      // In case of the string dont cast empty strings to nulls\n      result = castToStr;\n    }\n  }\n\n  return result;\n}\n","import { registry } from './class-metadata-registry';\nimport { isPrimitiveType, serializeUnionForLog } from './common';\nimport { InternalXmlPropertyOptions } from './internal-types';\nimport type {\n  XmlAttributeOptions,\n  XmlChardataOptions,\n  XmlChildElemOptions,\n  XmlElemOptions,\n} from './types';\n\n/**\n * A class decorator.\n * It can be omitted, but only if at least one Xml* property decorator is used on it's properties.\n *\n * @example\n * \\@XmlElem()\n * class EmptyXmlElement {}\n *\n * \\@XmlElem({ name: 'some-xml-element' })\n * class SomeXmlElement {\n *   \\@XmlChildElem()\n *   child: string;\n * }\n *\n * \\@XmlElem({ xmlns: 'http://s3.amazonaws.com/doc/2006-03-01/' })\n * class SomeXmlElement {\n *   \\@XmlChildElem()\n *   child: string;\n * }\n */\nexport function XmlElem(opts?: XmlElemOptions): ClassDecorator {\n  return (target: any): any => {\n    opts = opts || {};\n\n    opts.name = opts.name || target.name;\n\n    if (!opts.name) {\n      throw new Error(\n        `xml-class-transformer: Failed to get the element name for class ${target}. Specify it with @XmlElem({ name: '...' }) decorator.`,\n      );\n    }\n\n    registry.setEntityOptions(target, opts);\n\n    return target;\n  };\n}\n\n/**\n * Class property decorator.\n *\n * @example\n * class SomeElement {\n *   \\@XmlChildElem({ type: () => String })\n *   stringElem: string;\n *\n *   \\@XmlChildElem({ name: 'someOtherName', type: () => Number })\n *   numberElem: string;\n *\n *   \\@XmlChildElem({ type: () => NestedElem })\n *   nestedElem: NestedElem;\n * }\n */\nexport function XmlChildElem(opts: XmlChildElemOptions): PropertyDecorator {\n  return propertyDecoratorFactory('XmlChildElem', opts);\n}\n\n/**\n * Class property decorator.\n * For more details on options see {@link XmlAttributeOptions}\n *\n * @example\n * // a basic example\n * class SomeXmlElement {\n *   \\@XmlAttribute({ name: 'attributeName', type: () => String })\n *   attributeName: string;\n * }\n */\nexport function XmlAttribute(opts: XmlAttributeOptions): PropertyDecorator {\n  return propertyDecoratorFactory('XmlAttribute', {\n    ...opts,\n    attr: true,\n  });\n}\n\n/**\n * This decorator, when used on a class property, collects all the comments\n * from the provided XML, turns them into an array of strings and puts them into\n * that property. And vice-versa: at serialization that array of strings gets serialized to set of comments\n * in the resulting XML.\n *\n * @example\n * ```ts\n * class SomeElement {\n *   \\@XmlComments()\n *   comments?: string[];\n * }\n *\n * classToXml(\n *   new SomeElement({\n *     comments: ['some comment', 'some other comment']\n *   })\n * )\n * ```\n *\n * Output:\n * ```xml\n * <SomeElement>\n *   <!-- some comment -->\n *   <!-- some other comment -->\n * </SomeElement>\n *\n * ```\n */\nexport function XmlComments(): PropertyDecorator {\n  return (target: { constructor: any }, propertyKey: string | symbol): void => {\n    if (typeof propertyKey !== 'string') {\n      // Dont support symbols for now\n      throw new TypeError(\n        `xml-class-transformer: Can't use @XmlComments({...}) decorator on a symbol property ` +\n          `at ${target.constructor.name}#${propertyKey.toString()}`,\n      );\n    }\n\n    registry.setPropertyOptions(target.constructor, propertyKey, {\n      comments: true,\n    });\n  };\n}\n\n/**\n * The property will be parsed and serialized as a character data.\n * The \"type\" parameter can only be a primitive type: String, Number, Boolean.\n *\n * ```ts\n * \\@XmlElem({ name: 'Comment' })\n * class Comment {\n *   \\@XmlChardata({ type: () => String })\n *   text: string;\n *\n *   \\@XmlAttribute({ type: () => String, name: 'lang' })\n *   language: string;\n *\n *   constructor(d?: Comment) {\n *     Object.assign(this, d || {});\n *   }\n * }\n *\n * classToXml(\n *   new Comment({\n *     text: 'This is awesome',\n *     language: 'en',\n *   }),\n * )\n * ```\n *\n * Output:\n * ```xml\n * <Comment lang=\"en\">This is awesome</Comment>\n * ```\n */\nexport function XmlChardata(opts: XmlChardataOptions): PropertyDecorator {\n  return propertyDecoratorFactory('XmlChardata', {\n    ...opts,\n    chardata: true,\n  });\n}\n\nfunction propertyDecoratorFactory(\n  decoratorName: 'XmlAttribute' | 'XmlChildElem' | 'XmlChardata',\n  opts: InternalXmlPropertyOptions,\n): PropertyDecorator {\n  return (target: { constructor: any }, propertyKey: string | symbol): void => {\n    if (typeof propertyKey !== 'string') {\n      // Dont support symbols for now\n      throw new TypeError(\n        `xml-class-transformer: Can't use @${decoratorName}({...}) decorator on a symbol property ` +\n          `at ${target.constructor.name}#${propertyKey.toString()}`,\n      );\n    }\n\n    if (opts.union && opts.type) {\n      throw new TypeError(\n        `xml-class-transformer: The \"union\" option is not compatible with the \"type\" option at ` +\n          `${target.constructor.name}#${propertyKey.toString()}.`,\n      );\n    }\n\n    if (!opts.union && !opts.type) {\n      throw new TypeError(\n        `xml-class-transformer: No \"type\" or \"union\" was specified for the ` +\n          `${target.constructor.name}#${propertyKey.toString()}. Add it to ` +\n          `the @${decoratorName}({...}) decorator.`,\n      );\n    }\n\n    if (opts.union && !opts.union().length) {\n      throw new TypeError(\n        `xml-class-transformer: The \"union\" option in @${decoratorName}({ ... }) can't be empty ` +\n          `at ${\n            target.constructor.name\n          }#${propertyKey.toString()}. Either remove the \"union\" option or provide it with at least one type.`,\n      );\n    }\n\n    if (opts.union) {\n      if (opts.name) {\n        throw new TypeError(\n          `xml-class-transformer: The \"union\" option is not compatible with the \"name\" option at ` +\n            `${target.constructor.name}#${propertyKey.toString()}. ` +\n            `XML element names for the union members should be specified at ` +\n            `the union member classes.`,\n        );\n      }\n    } else {\n      opts.name = opts.name || propertyKey;\n    }\n\n    if (opts.union) {\n      // opts.union() at the moment of running this peace of code can potentially return\n      // undefineds as the value of some elements in case if there are circular dependencies.\n      // But the primitive values constructors (String, Number and Boolean) are always defined.\n      // So it's okay to check them like this:\n      const unionArr = opts.union();\n      const foundPrimitiveType = unionArr.find((type) => isPrimitiveType(type));\n\n      if (foundPrimitiveType) {\n        throw new TypeError(\n          `xml-class-transformer: unions of primitive types (String, Number or Boolean) are not supported. ` +\n            `Fix it in the decorator @${decoratorName}({ ` +\n            `union: ${serializeUnionForLog(unionArr)}, ... }) ` +\n            `at \"${target.constructor.name}#${propertyKey.toString()}\".`,\n        );\n      }\n    }\n\n    registry.setPropertyOptions(target.constructor, propertyKey, opts);\n  };\n}\n"],"names":["registry","constructor","this","Map","setEntityOptions","xClass","opts","metadata","get","entity","set","properties","setPropertyOptions","propertyKey","getOrCreate","comments","searchingPropKey","searchingOpts","Error","name","JSON","stringify","chardata","existing","newMetadatas","errUnknownClass","classConstructor","isPrimitiveType","type","String","Number","BigInt","Boolean","classToXmlInternal","entityConstructor","elements","text","meta","elemName","children","attributes","forEach","classKey","undefined","Array","isArray","comment","push","attr","array","_a","e","union","xmlns","xmlToClassInternal","element","_class","parsePrimitive","el","child","getChardataFromElem","metadatas","inst","key","commentsAccumulated","childElem","tagNameToClassType","classType","classTypeMetadata","tagName","possibleTagNames","keys","resolvedValues","_b","includes","elems","_c","filter","matchingXmlElement","_d","find","has","_e","value","result","castToStr","parseFloat","propertyDecoratorFactory","decoratorName","target","TypeError","toString","length","unionArr","map","t","join","Object","assign","options","rootElem","declaration","version","encoding","xmljs","js2xml","xml","firstElement","xml2js","compact","alwaysArray"],"mappings":"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"}