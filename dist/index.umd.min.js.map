{"version":3,"file":"index.umd.min.js","sources":["../src/class-metadata-registry.ts","../src/xml-class-transformer.ts","../src/decorators.ts"],"sourcesContent":["import type { AnyClass, XmlEntityOptions, XmlPropertyOptions } from './types';\n\ntype ClassMetadatas = {\n  properties: Map<string, XmlPropertyOptions>;\n  entity: XmlEntityOptions;\n};\n\nexport class ClassMetadataRegistry {\n  private registry = new Map<AnyClass, ClassMetadatas>();\n\n  setEntityOptions(clazz: AnyClass, opts: XmlEntityOptions): void {\n    const metadata = this.registry.get(clazz);\n\n    if (metadata) {\n      metadata.entity = opts;\n    } else {\n      this.registry.set(clazz, {\n        entity: opts,\n        properties: new Map(),\n      });\n    }\n  }\n\n  setPropertyOptions(\n    clazz: AnyClass,\n    propertyKey: string,\n    opts: XmlPropertyOptions,\n  ): void {\n    const metadata = this.getOrCreate(clazz);\n\n    if (opts.name) {\n      for (const [searchingPropKey, searchingOpts] of metadata.properties) {\n        if (searchingOpts.name === opts.name) {\n          throw new Error(\n            `xml-class-transformer: can't use XML element name defined in { name: ${JSON.stringify(\n              opts.name,\n            )} } for ${clazz.name}#${propertyKey} since it's already used for ${\n              clazz.name\n            }#${searchingPropKey}. Change it to something else.`,\n          );\n        }\n      }\n    }\n\n    metadata.properties.set(propertyKey, opts);\n  }\n\n  private getOrCreate(clazz: AnyClass): ClassMetadatas {\n    const existing = this.registry.get(clazz);\n    if (existing) {\n      return existing;\n    } else {\n      const newMetadatas: ClassMetadatas = {\n        entity: {},\n        properties: new Map(),\n      };\n\n      this.registry.set(clazz, newMetadatas);\n\n      return newMetadatas;\n    }\n  }\n\n  get(clazz: AnyClass): ClassMetadatas | undefined {\n    return this.registry.get(clazz);\n  }\n}\n\nexport const registry = new ClassMetadataRegistry();\n","import xmljs from 'xml-js';\nimport { registry } from './class-metadata-registry';\nimport type { AnyClass, ClassToXmlOptions, XmlType } from './types';\n\nexport function xmlToClass<T extends AnyClass>(\n  xml: string,\n  _class: T,\n): InstanceType<T> {\n  const parsed = xmljs.xml2js(xml, {\n    compact: false,\n    alwaysArray: true,\n  }) as xmljs.Element;\n\n  const firstElement = parsed.elements?.[0];\n\n  if (!firstElement) {\n    throw new Error('No elements found in xml.');\n  }\n\n  return xmlToClassInternal(firstElement, _class);\n}\n\nfunction xmlToClassInternal(element: xmljs.Element, _class: any): any {\n  if ([String, Number, Boolean].includes(_class)) {\n    let value: unknown = undefined;\n\n    const text = getTextForElem(element)?.toString();\n\n    if (_class === String) {\n      value = text;\n    } else if (_class === Number) {\n      value = text ? parseInt(text, 10) : undefined;\n    } else if (_class === Boolean) {\n      value = text ? text === 'true' : undefined;\n    }\n\n    return value;\n  }\n\n  const metadatas = registry.get(_class);\n\n  if (!metadatas) {\n    throw new Error('Unknown class ' + _class);\n  }\n\n  const inst = new _class();\n\n  metadatas.properties.forEach((metadata, key) => {\n    if (metadata.attr) {\n      if (!metadata.name) {\n        throw new Error(\n          `No name is specified for attribute ${key}. Specify it with @XmlProperty({ name: '...' }) decorator.`,\n        );\n      }\n\n      const attr = element.attributes?.[metadata.name];\n\n      if (attr) {\n        inst[key] = attr;\n      } else {\n        inst[key] = undefined;\n      }\n    } else if (metadata.chardata) {\n      inst[key] = xmlToClassInternal(element, metadata.type);\n    } else if (metadata.array) {\n      if (Array.isArray(metadata.type)) {\n        const tagNameToClassType: Map<string, any> = new Map();\n\n        metadata.type.forEach((classType) => {\n          const classTypeMetadata = registry.get(classType);\n\n          if (!classTypeMetadata) {\n            throw errUnknownClass(classType);\n          }\n\n          const tagName = classTypeMetadata.entity.name;\n\n          if (!tagName) {\n            throw new Error(\n              `No name is specified for ${classType}. Specify it with @XmlEntity({ name: '...' }) decorator.`,\n            );\n          }\n\n          tagNameToClassType.set(tagName, classType);\n        });\n\n        const possibleTagNames = [...tagNameToClassType.keys()];\n\n        const resolvedValues: any[] = [];\n\n        element.elements?.forEach((el) => {\n          if (el.name && possibleTagNames.includes(el.name)) {\n            const classType = tagNameToClassType.get(el.name);\n\n            const entity = xmlToClassInternal(el, classType);\n\n            resolvedValues.push(entity);\n          }\n        });\n\n        inst[key] = resolvedValues;\n      } else {\n        const elems =\n          element.elements?.filter((e) => e.name === metadata.name) || [];\n\n        const resolvedValues: any[] = [];\n\n        elems.forEach((el) => {\n          const entity = xmlToClassInternal(el, metadata.type as XmlType);\n\n          resolvedValues.push(entity);\n        });\n\n        inst[key] = resolvedValues;\n      }\n    } else {\n      const el = element.elements?.find((el) => el.name === metadata.name);\n\n      if (el) {\n        const value: any = xmlToClassInternal(el, metadata.type);\n\n        inst[key] = value;\n      } else {\n        inst[key] = undefined;\n      }\n    }\n  });\n\n  return inst;\n}\n\nfunction getTextForElem(el: xmljs.Element): string | undefined {\n  return el.elements?.find((e) => e.type === 'text')?.text as string;\n}\n\nexport function classToXml(entity: any, options?: ClassToXmlOptions): string {\n  const tree = classToXmlInternal(entity, '', entity.constructor);\n\n  const rootElem: xmljs.Element = { elements: [tree] };\n\n  if (options?.declaration !== false) {\n    if (\n      typeof options?.declaration === 'object' &&\n      options?.declaration !== null\n    ) {\n      rootElem.declaration = options.declaration;\n    } else {\n      rootElem.declaration = {\n        attributes: { version: '1.0', encoding: 'UTF-8' },\n      };\n    }\n  }\n\n  return xmljs.js2xml(rootElem, options);\n}\n\nfunction classToXmlInternal(\n  entity: any,\n  name: string,\n  entityConstructor: any,\n): xmljs.Element {\n  if ([String, Number, Boolean].includes(entityConstructor)) {\n    const text = entity === null ? '' : entity?.toString();\n\n    return {\n      type: 'element',\n      name: name,\n      elements: [\n        {\n          type: 'text',\n          text,\n        },\n      ],\n    };\n  }\n\n  const meta = registry.get(entityConstructor);\n\n  if (!meta) {\n    throw errUnknownClass(entityConstructor);\n  }\n\n  const elemName = name || meta.entity.name;\n\n  if (!elemName) {\n    throw new Error(\n      `No name is specified for ${entityConstructor}. Specify it with @XmlEntity({ name: '...' }) decorator.`,\n    );\n  }\n\n  const children: xmljs.Element[] = [];\n\n  const attributes: xmljs.Attributes = {};\n\n  meta.properties.forEach((opts, classKey) => {\n    if (entity[classKey] === undefined) {\n      return;\n    }\n\n    if (opts.attr) {\n      if (!opts.name) {\n        throw new Error(\n          `No name is specified for property ${classKey}. Specify it with @XmlProperty({ name: '...' }) decorator.`,\n        );\n      }\n      attributes[opts.name] =\n        entity[classKey] === null ? '' : entity[classKey].toString();\n    } else if (opts.chardata) {\n      children.push({\n        type: 'text',\n        text: entity[classKey] === null ? '' : entity[classKey].toString(),\n      });\n    } else if (opts.array) {\n      entity[classKey]?.forEach((e: any) => {\n        // If opts.type is an array then we can't guess required class out of it.\n        // In those cases users should use class constructors (aka new MyEntity({...}))\n        // so the library can guess the class type just by looking at myEntity.constructor\n        const classConstructor = Array.isArray(opts.type)\n          ? e.constructor\n          : opts.type;\n        children.push(classToXmlInternal(e, opts.name!, classConstructor));\n      });\n    } else if ([String, Number, Boolean].includes(opts.type as any)) {\n      if (!opts.name) {\n        throw new Error(\n          `No name is specified for property ${classKey}. Specify it with @XmlProperty({ name: '...' }) decorator.`,\n        );\n      }\n      children.push(\n        classToXmlInternal(entity[opts.name], opts.name, opts.type),\n      );\n    } else {\n      children.push(\n        classToXmlInternal(entity[classKey], opts.name!, opts.type),\n      );\n    }\n  });\n\n  if (meta.entity.xmlns) {\n    attributes['xmlns'] = meta.entity.xmlns;\n  }\n\n  return {\n    type: 'element',\n    name: elemName,\n    attributes,\n    elements: children,\n  };\n}\n\nfunction errUnknownClass(classConstructor: any): Error {\n  return new Error(\n    `Class ${classConstructor} not found. Make sure there is @XmlEntity({...}) decorator on it, or @XmlProperty({...}) decorator on its properties.`,\n  );\n}\n","import { registry } from './class-metadata-registry';\nimport type { XmlEntityOptions, XmlPropertyOptions } from './types';\n\n/**\n * Class decorator\n */\nexport function XmlEntity(opts?: XmlEntityOptions): ClassDecorator {\n  return (target: any): any => {\n    opts = opts || {};\n\n    opts.name = opts.name || target.name;\n\n    if (!opts.name) {\n      throw new Error(\n        `Failed to get the element name for class ${target}. Specify it with @XmlEntity({ name: '...' }) decorator.`,\n      );\n    }\n\n    registry.setEntityOptions(target, opts);\n\n    return target;\n  };\n}\n\n/**\n * Class property decorator\n */\nexport function XmlProperty(opts: XmlPropertyOptions): PropertyDecorator {\n  return (target: { constructor: any }, propertyKey: string | symbol): void => {\n    opts.name === opts.name || propertyKey;\n\n    if (typeof propertyKey !== 'string') {\n      throw new TypeError(\n        `Can't use @XmlProperty({...}) decorator on symbol property at ${\n          target.constructor.name\n        }#${propertyKey.toString()}`,\n      );\n    }\n\n    registry.setPropertyOptions(target.constructor, propertyKey, opts);\n  };\n}\n"],"names":["registry","constructor","this","Map","setEntityOptions","clazz","opts","metadata","get","entity","set","properties","setPropertyOptions","propertyKey","getOrCreate","name","searchingPropKey","searchingOpts","Error","JSON","stringify","existing","newMetadatas","xmlToClassInternal","element","_class","String","Number","Boolean","includes","value","text","_a","el","_b","elements","find","e","type","getTextForElem","toString","parseInt","undefined","metadatas","inst","forEach","key","attr","attributes","chardata","array","Array","isArray","tagNameToClassType","classType","classTypeMetadata","errUnknownClass","tagName","possibleTagNames","keys","resolvedValues","push","elems","_c","filter","_d","classToXmlInternal","entityConstructor","meta","elemName","children","classKey","classConstructor","xmlns","target","TypeError","options","rootElem","declaration","version","encoding","xmljs","js2xml","xml","firstElement","xml2js","compact","alwaysArray"],"mappings":"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"}