{"version":3,"file":"index.umd.min.js","sources":["../src/class-metadata-registry.ts","../src/common.ts","../src/transform-class-to-xml.ts","../src/transform-xml-to-class.ts","../src/decorators.ts"],"sourcesContent":["import type { AnyClass, XmlEntityOptions, XmlPropertyOptions } from './types';\n\ntype ClassMetadatas = {\n  properties: Map<string, XmlPropertyOptions>;\n  entity: XmlEntityOptions;\n};\n\nexport class ClassMetadataRegistry {\n  private registry = new Map<AnyClass, ClassMetadatas>();\n\n  setEntityOptions(clazz: AnyClass, opts: XmlEntityOptions): void {\n    const metadata = this.registry.get(clazz);\n\n    if (metadata) {\n      metadata.entity = opts;\n    } else {\n      this.registry.set(clazz, {\n        entity: opts,\n        properties: new Map(),\n      });\n    }\n  }\n\n  setPropertyOptions(\n    clazz: AnyClass,\n    propertyKey: string,\n    opts: XmlPropertyOptions,\n  ): void {\n    const metadata = this.getOrCreate(clazz);\n\n    if (opts.name) {\n      for (const [searchingPropKey, searchingOpts] of metadata.properties) {\n        if (searchingOpts.name === opts.name) {\n          throw new Error(\n            `xml-class-transformer: can't use XML element name defined in ` +\n              `{ name: ${JSON.stringify(opts.name)} } for ` +\n              `${clazz.name}#${propertyKey} since it's already used for ` +\n              `${clazz.name}#${searchingPropKey}. Change it to something else.`,\n          );\n        }\n\n        // TODO: maybe support multiple chardata for multiple child text nodes inside an xml element.\n        // each of those chardata properties whould match the text node at the same position as the property itself.\n        // The same goes for not yet implemented comments and cdata.\n        if (opts.chardata && searchingOpts.chardata) {\n          throw new Error(\n            `xml-class-transformer: an XML element can have only one chardata property. ` +\n              `Both ${clazz.name}#${propertyKey} and ${clazz.name}#${searchingOpts.name} ` +\n              `are defined as chardata, which is not valid.`,\n          );\n        }\n      }\n    }\n\n    metadata.properties.set(propertyKey, opts);\n  }\n\n  private getOrCreate(clazz: AnyClass): ClassMetadatas {\n    const existing = this.registry.get(clazz);\n    if (existing) {\n      return existing;\n    } else {\n      const newMetadatas: ClassMetadatas = {\n        entity: {\n          name: clazz?.name,\n        },\n        properties: new Map(),\n      };\n\n      this.registry.set(clazz, newMetadatas);\n\n      return newMetadatas;\n    }\n  }\n\n  get(clazz: AnyClass): ClassMetadatas | undefined {\n    return this.registry.get(clazz);\n  }\n}\n\nexport const registry = new ClassMetadataRegistry();\n","export function errUnknownClass(classConstructor: any): Error {\n  return new Error(\n    `Class \"${classConstructor}\" not found. Make sure there is a @XmlEntity({...}) decorator on it, or @XmlProperty({...}) decorator on its properties.`,\n  );\n}\n\nexport function serializeUnionForLog(union: any[]): string {\n  return (\n    '[' +\n    union\n      .map((t) =>\n        t === null ? 'null' : t === undefined ? 'undefined' : t.name,\n      )\n      .join(', ') +\n    ']'\n  );\n}\n","import xmljs from 'xml-js';\nimport { registry } from './class-metadata-registry';\nimport { ClassToXmlOptions } from './types';\nimport { errUnknownClass } from './common';\n\nexport function classToXml(entity: any, options?: ClassToXmlOptions): string {\n  const tree = classToXmlInternal(entity, '', entity.constructor);\n\n  const rootElem: xmljs.Element = { elements: [tree] };\n\n  if (options?.declaration !== false) {\n    if (\n      typeof options?.declaration === 'object' &&\n      options?.declaration !== null\n    ) {\n      rootElem.declaration = options.declaration;\n    } else {\n      rootElem.declaration = {\n        attributes: { version: '1.0', encoding: 'UTF-8' },\n      };\n    }\n  }\n\n  return xmljs.js2xml(rootElem, options);\n}\n\nfunction classToXmlInternal(\n  entity: any,\n  name: string | undefined,\n  entityConstructor: any,\n): xmljs.Element {\n  if ([String, Number, Boolean].includes(entityConstructor)) {\n    const text = entity === null ? '' : `${entity}`;\n\n    return {\n      type: 'element',\n      name: name!,\n      elements: [\n        {\n          type: 'text',\n          text,\n        },\n      ],\n    };\n  }\n\n  const meta = registry.get(entityConstructor);\n\n  if (!meta) {\n    throw errUnknownClass(entityConstructor);\n  }\n\n  const elemName = name || meta.entity.name;\n\n  if (!elemName) {\n    throw new Error(\n      `No XML name is specified for the class \"${entityConstructor?.name}\". Specify it with the @XmlEntity({ name: '...' }) decorator.`,\n    );\n  }\n\n  const children: xmljs.Element[] = [];\n\n  const attributes: xmljs.Attributes = {};\n\n  meta.properties.forEach((opts, classKey) => {\n    // Do not emit attribute if value is undefined,\n    if (entity[classKey] === undefined) {\n      return;\n    }\n\n    if (opts.attr) {\n      if (!opts.name) {\n        throw new Error(\n          `No name is specified for the property ${entityConstructor?.name}#${classKey}. Specify it with the @XmlProperty({ name: '...' }) decorator.`,\n        );\n      }\n\n      attributes[opts.name] =\n        entity[classKey] === null ? '' : `${entity[classKey]}`;\n    } else if (opts.chardata) {\n      children.push({\n        type: 'text',\n        text: entity[classKey] === null ? '' : `${entity[classKey]}`,\n      });\n    } else if (opts.array) {\n      if (entity[classKey] === null) {\n        return;\n      }\n\n      entity[classKey]?.forEach((e: any) => {\n        // Do not process null and undefined values in the array.\n        // When we impl support for primitive unions maybe this should change\n        if (!e) {\n          return;\n        }\n\n        // If it is a union then we can't guess required class out of it.\n        // In those cases users should give to the library actual class instances (aka new MyEntity({...}))\n        // so the library can guess the class type just by looking at the myEntity.constructor\n        const classConstructor = opts.union ? e.constructor : opts.type;\n        // The opts.name will be undefined if !!opts.union, but thats ok.\n        children.push(classToXmlInternal(e, opts.name, classConstructor));\n      });\n    } else if ([String, Number, Boolean].includes(opts.type as any)) {\n      if (!opts.name) {\n        throw new Error(\n          `No name is specified for property ${entityConstructor?.name}#${classKey}. Specify it with @XmlProperty({ name: '...' }) decorator.`,\n        );\n      }\n      children.push(classToXmlInternal(entity[classKey], opts.name, opts.type));\n    } else if (opts.union) {\n      // should work with primitive types also\n      const classConstructor = entity[classKey].constructor;\n\n      children.push(\n        classToXmlInternal(entity[classKey], undefined, classConstructor),\n      );\n    } else {\n      // If null then just skip this embedded element for the current impl\n      // TODO: maybe non array unions are borken\n      if (entity[classKey] !== null) {\n        children.push(\n          classToXmlInternal(\n            entity[classKey],\n            opts.name,\n            opts.union ? entity[classKey].constructor : opts.type,\n          ),\n        );\n      }\n    }\n  });\n\n  if (meta.entity.xmlns) {\n    attributes['xmlns'] = meta.entity.xmlns;\n  }\n\n  return {\n    type: 'element',\n    name: elemName,\n    attributes,\n    elements: children,\n  };\n}\n","import xmljs from 'xml-js';\nimport { registry } from './class-metadata-registry';\nimport type { AnyClass, XmlPrimitiveType, XmlType } from './types';\nimport { errUnknownClass } from './common';\n\nexport function xmlToClass<T extends AnyClass>(\n  xml: string,\n  _class: T,\n): InstanceType<T> {\n  const parsed = xmljs.xml2js(xml, {\n    compact: false,\n    alwaysArray: true,\n  }) as xmljs.Element;\n\n  const firstElement = parsed.elements?.[0];\n\n  if (!firstElement) {\n    throw new Error('No elements found in xml.');\n  }\n\n  return xmlToClassInternal(firstElement, _class);\n}\n\nfunction xmlToClassInternal(element: xmljs.Element, _class: any): any {\n  if ([String, Number, Boolean].includes(_class)) {\n    const text = getTextForElem(element);\n\n    return parsePrimitive(text, _class);\n  }\n\n  const metadatas = registry.get(_class);\n\n  if (!metadatas) {\n    throw new Error('Unknown class ' + _class);\n  }\n\n  const inst = new _class();\n\n  metadatas.properties.forEach((metadata, key) => {\n    if (metadata.attr) {\n      if (!metadata.name) {\n        throw new Error(\n          `No name is specified for attribute ${key}. Specify it with @XmlProperty({ name: '...' }) decorator.`,\n        );\n      }\n\n      const attr = element.attributes?.[metadata.name];\n\n      if (attr !== undefined && attr !== null) {\n        inst[key] = parsePrimitive(\n          attr,\n          metadata.type as XmlPrimitiveType | undefined,\n        );\n      } else {\n        // If the attribute property is undefined - it means\n        // that the attribute was not present in the xml.\n        inst[key] = undefined;\n      }\n    } else if (metadata.chardata) {\n      inst[key] = xmlToClassInternal(element, metadata.type);\n    } else if (metadata.array) {\n      if (metadata.union) {\n        // TODO: optimize and cache this map:\n        const tagNameToClassType: Map<string, any> = new Map();\n\n        metadata.union.forEach((classType) => {\n          const classTypeMetadata = registry.get(classType);\n\n          if (!classTypeMetadata) {\n            throw errUnknownClass(classType);\n          }\n\n          const tagName = classTypeMetadata.entity.name;\n\n          if (!tagName) {\n            throw new Error(\n              `No name is specified for ${classType}. Specify it with the @XmlEntity({ name: '...' }) decorator.`,\n            );\n          }\n\n          tagNameToClassType.set(tagName, classType);\n        });\n\n        const possibleTagNames = [...tagNameToClassType.keys()];\n\n        const resolvedValues: any[] = [];\n\n        element.elements?.forEach((el) => {\n          if (el.name && possibleTagNames.includes(el.name)) {\n            const classType = tagNameToClassType.get(el.name);\n\n            const entity = xmlToClassInternal(el, classType);\n\n            resolvedValues.push(entity);\n          }\n        });\n\n        inst[key] = resolvedValues;\n      } else {\n        const elems =\n          element.elements?.filter((e) => e.name === metadata.name) || [];\n\n        const resolvedValues: any[] = [];\n\n        elems.forEach((el) => {\n          const entity = xmlToClassInternal(el, metadata.type as XmlType);\n\n          resolvedValues.push(entity);\n        });\n\n        inst[key] = resolvedValues;\n      }\n    } else if (metadata.union) {\n      // TODO: optimize and cache this map:\n      const tagNameToClassType: Map<string, any> = new Map();\n\n      metadata.union.forEach((classType) => {\n        const classTypeMetadata = registry.get(classType);\n\n        if (!classTypeMetadata) {\n          throw errUnknownClass(classType);\n        }\n\n        const tagName = classTypeMetadata.entity.name;\n\n        if (!tagName) {\n          throw new Error(\n            `No name is specified for ${classType}. Specify it with the @XmlEntity({ name: '...' }) decorator.`,\n          );\n        }\n\n        tagNameToClassType.set(tagName, classType);\n      });\n\n      const matchingXmlElement = element.elements?.find((el) => {\n        return el.name && tagNameToClassType.has(el.name);\n      });\n\n      inst[key] = matchingXmlElement\n        ? xmlToClassInternal(\n            matchingXmlElement,\n            tagNameToClassType.get(matchingXmlElement.name!)!,\n          )\n        : undefined;\n    } else {\n      const el = element.elements?.find((el) => el.name === metadata.name);\n\n      if (el) {\n        const value: any = xmlToClassInternal(el, metadata.type);\n\n        inst[key] = value;\n      } else {\n        inst[key] = undefined;\n      }\n    }\n  });\n\n  return inst;\n}\n\nfunction getTextForElem(el: xmljs.Element): string {\n  return (el.elements?.find((e) => e.type === 'text')?.text as string) || '';\n}\n\nfunction parsePrimitive(\n  // Support numbers also\n  value: string | number | undefined,\n  classConstructor: XmlPrimitiveType | undefined,\n): number | string | boolean | null | undefined {\n  let result: number | string | boolean | null | undefined = undefined;\n\n  if (value === undefined) {\n    result = undefined;\n  } else {\n    const castToStr = `${value}`;\n\n    if (classConstructor === Number) {\n      result =\n        // parse empty strings to nulls when the specified type is Number\n        // bacause there is no convenient way to represent an empty string as a number,\n        // there is an idea to convert them to 0, but it's an implicit and non obvious behaviour.\n        // Maybe a better idea would be to convert them to NaN just as parseFloat does.\n        castToStr === '' ? null : castToStr ? parseFloat(castToStr) : undefined;\n    } else if (classConstructor === Boolean) {\n      result =\n        castToStr === '' ? null : castToStr ? castToStr === 'true' : undefined;\n    } else {\n      // classConstructor is String or any other type, then fallback to String:\n      // In case of the string dont cast empty strings to nulls\n      result = castToStr;\n    }\n  }\n\n  return result;\n}\n","import { registry } from './class-metadata-registry';\nimport { serializeUnionForLog } from './common';\nimport type {\n  XmlAttributeOptions,\n  XmlEntityOptions,\n  XmlPropertyOptions,\n} from './types';\n\n/**\n * Class decorator\n */\nexport function XmlEntity(opts?: XmlEntityOptions): ClassDecorator {\n  return (target: any): any => {\n    opts = opts || {};\n\n    opts.name = opts.name || target.name;\n\n    if (!opts.name) {\n      throw new Error(\n        `xml-class-transformer: Failed to get the element name for class ${target}. Specify it with @XmlEntity({ name: '...' }) decorator.`,\n      );\n    }\n\n    registry.setEntityOptions(target, opts);\n\n    return target;\n  };\n}\n\n/**\n * Class property decorator.\n */\nexport function XmlProperty(opts: XmlPropertyOptions): PropertyDecorator {\n  return propertyDecoratorFactory('XmlProperty', opts);\n}\n\n/**\n * Class property decorator.\n * For more details on options see {@link XmlAttributeOptions}\n *\n * @example\n * // a basic example\n * class SomeXmlElement {\n *   *XmlAttribute({ name: 'attributeName', type: String })\n *   attributeName: string;\n * }\n */\nexport function XmlAttribute(opts: XmlAttributeOptions): PropertyDecorator {\n  return propertyDecoratorFactory('XmlAttribute', {\n    ...opts,\n    attr: true,\n  });\n}\n\nfunction propertyDecoratorFactory(\n  decoratorName: 'XmlAttribute' | 'XmlProperty',\n  opts: XmlPropertyOptions,\n): PropertyDecorator {\n  return (target: { constructor: any }, propertyKey: string | symbol): void => {\n    if (typeof propertyKey !== 'string') {\n      // Dont support symbols for now\n      throw new TypeError(\n        `xml-class-transformer: Can't use @${decoratorName}({...}) decorator on a symbol property ` +\n          `at ${target.constructor.name}#${propertyKey.toString()}`,\n      );\n    }\n\n    if (opts.union && opts.type) {\n      throw new TypeError(\n        `xml-class-transformer: The \"union\" option is not compatible with the \"type\" option at ` +\n          `${target.constructor.name}#${propertyKey.toString()}.`,\n      );\n    }\n\n    if (!opts.union && !opts.type) {\n      throw new TypeError(\n        `xml-class-transformer: No \"type\" or \"union\" was specified for the ` +\n          `${target.constructor.name}#${propertyKey.toString()}. Add it to ` +\n          `the @${decoratorName}({...}) decorator.`,\n      );\n    }\n\n    if (opts.union && !opts.union.length) {\n      throw new TypeError(\n        `xml-class-transformer: The \"union\" option in @${decoratorName}({ ... }) can't be empty ` +\n          `at ${target.constructor.name}#${propertyKey.toString()}.`,\n      );\n    }\n\n    if (opts.union) {\n      if (opts.name) {\n        throw new TypeError(\n          `xml-class-transformer: The \"union\" option is not compatible with the \"name\" option at ` +\n            `${target.constructor.name}#${propertyKey.toString()}. ` +\n            `XML element names for the union memebers should be specified at ` +\n            `the union memeber classes.`,\n        );\n      }\n    } else {\n      opts.name = opts.name || propertyKey;\n    }\n\n    if (\n      opts.union &&\n      (opts.union.includes(String) ||\n        opts.union.includes(Number) ||\n        opts.union.includes(Boolean))\n    ) {\n      throw new TypeError(\n        `xml-class-transformer: unions of primitive types (String, Number or Boolean) are not supported. ` +\n          `Fix it in the decorator @${decoratorName}({ ` +\n          `union: ${serializeUnionForLog(opts.union)}, ... }) ` +\n          `at \"${target.constructor.name}#${propertyKey.toString()}\".`,\n      );\n    }\n\n    registry.setPropertyOptions(target.constructor, propertyKey, opts);\n  };\n}\n"],"names":["registry","constructor","this","Map","setEntityOptions","clazz","opts","metadata","get","entity","set","properties","setPropertyOptions","propertyKey","getOrCreate","name","searchingPropKey","searchingOpts","Error","JSON","stringify","chardata","existing","newMetadatas","errUnknownClass","classConstructor","classToXmlInternal","entityConstructor","String","Number","Boolean","includes","type","elements","text","meta","elemName","children","attributes","forEach","classKey","undefined","attr","push","array","_a","e","union","xmlns","xmlToClassInternal","element","_class","parsePrimitive","_b","find","metadatas","inst","key","tagNameToClassType","classType","classTypeMetadata","tagName","possibleTagNames","keys","resolvedValues","el","elems","_c","filter","matchingXmlElement","_d","has","_e","value","result","castToStr","parseFloat","propertyDecoratorFactory","decoratorName","target","TypeError","toString","length","map","t","join","Object","assign","options","rootElem","declaration","version","encoding","xmljs","js2xml","xml","firstElement","xml2js","compact","alwaysArray"],"mappings":"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"}