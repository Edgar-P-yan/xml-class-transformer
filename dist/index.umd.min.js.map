{"version":3,"file":"index.umd.min.js","sources":["../src/index.ts"],"sourcesContent":["import xmljs from 'xml-js';\n\nexport type AnyClass = { new (): any };\n\nexport type XmlType = typeof String | typeof Number | typeof Boolean | AnyClass;\n\nexport interface XmlEntityOptions {\n  /**\n   * xmlns attribute value.\n   * This is just a shortcut for @XmlAttribute({ name: 'xmlns', value: '...' }) property decorator.\n   */\n  xmlns?: string;\n\n  /**\n   * XML element name.\n   * If not specified, the class name will be used.\n   */\n  name?: string;\n}\n\nexport interface XmlPropertyOptions {\n  /**\n   * Specify primitive type or class type for parsing and serializing.\n   * @example\n   * { type: String }\n   *\n   * You can also specify multiple classes, then the one whose name matches the element name will be selected.\n   * @example\n   * { type: [Version, DeleteMarker] }\n   */\n  type: XmlType | XmlType[];\n\n  /**\n   * If true, the property will be parsed and serialized as an array.\n   * Not compatible with `attr` and `chardata` options.\n   */\n  array?: boolean;\n\n  /**\n   * XML element name.\n   * If not specified, the property name will be used.\n   * It is highly recommended to specify it explicitly.\n   *\n   * Not compatible with `chardata` options.\n   */\n  name?: string | undefined;\n\n  /**\n   * If true, the property will be parsed and serialized as an attribute.\n   */\n  attr?: boolean;\n\n  /**\n   * If true, the property will be parsed and serialized as a character data.\n   * Not compatible with `array` and `attr` options.\n   *\n   * It's only useful when you parse elements with a text node and no attributes.\n   *\n   * @example\n   * *XmlEntity({ name: 'Comment' })\n   * class Comment {\n   *  *XmlProperty({ chardata: true })\n   *  text: string;\n   *\n   *  *XmlProperty({ name: 'lang', attr: true })\n   *  lenguage: string;\n   *\n   *  constructor(d?: Comment) {\n   *   Object.assign(this, d || {});\n   *  }\n   * }\n   *\n   * classToXml(\n   *  new Comment({\n   *    text: 'This is awesome',\n   *    lenguage: 'en',\n   *  })\n   * )\n   *\n   * // Output:\n   * <Comment lang=\"en\">This is awesome</Comment>\n   */\n  chardata?: boolean;\n}\n\ntype ClassMetadatas = {\n  properties: Map<string, XmlPropertyOptions>;\n  entity: XmlEntityOptions;\n};\n\nconst registry: Map<AnyClass, ClassMetadatas> = new Map();\n\n/**\n * Class decorator\n */\nexport function XmlEntity(opts?: XmlEntityOptions): ClassDecorator {\n  return (target: any): any => {\n    opts = opts || {};\n\n    opts.name = opts.name || target.name;\n\n    if (!opts.name) {\n      throw new Error(\n        `Failed to get the element name for class ${target}. Specify it with @XmlEntity({ name: '...' }) decorator.`,\n      );\n    }\n\n    const metadata = registry.get(target);\n\n    if (metadata) {\n      metadata.entity = opts;\n    } else {\n      registry.set(target, {\n        entity: opts,\n        properties: new Map(),\n      });\n    }\n\n    return target;\n  };\n}\n\n/**\n * Class property decorator\n */\nexport function XmlProperty(opts: XmlPropertyOptions): PropertyDecorator {\n  return (target: { constructor: any }, propertyKey: string | symbol): void => {\n    opts.name === opts.name || propertyKey;\n\n    if (typeof propertyKey !== 'string') {\n      throw new TypeError(\n        `Can't use @XmlProperty({...}) decorator on symbol property at ${\n          target.constructor.name\n        }#${propertyKey.toString()}`,\n      );\n    }\n\n    const metadata = registry.get(target.constructor);\n    if (metadata) {\n      metadata.properties.set(propertyKey, opts);\n    } else {\n      registry.set(target.constructor, {\n        properties: new Map([[propertyKey, opts]]),\n        entity: {},\n      });\n    }\n  };\n}\n\nexport function xmlToClass<T extends AnyClass>(\n  xml: string,\n  _class: T,\n): InstanceType<T> {\n  const parsed = xmljs.xml2js(xml, {\n    compact: false,\n    alwaysArray: true,\n  }) as xmljs.Element;\n\n  const firstElement = parsed.elements?.[0];\n\n  if (!firstElement) {\n    throw new Error('No elements found in xml.');\n  }\n\n  return xmlToClassInternal(firstElement, _class);\n}\n\nfunction xmlToClassInternal(element: xmljs.Element, _class: any): any {\n  if ([String, Number, Boolean].includes(_class)) {\n    let value: unknown = undefined;\n\n    const text = getTextForElem(element)?.toString();\n\n    if (_class === String) {\n      value = text;\n    } else if (_class === Number) {\n      value = text ? parseInt(text, 10) : undefined;\n    } else if (_class === Boolean) {\n      value = text ? text === 'true' : undefined;\n    }\n\n    return value;\n  }\n\n  const metadatas = registry.get(_class);\n\n  if (!metadatas) {\n    throw new Error('Unknown class ' + _class);\n  }\n\n  const inst = new _class();\n\n  metadatas.properties.forEach((metadata, key) => {\n    if (metadata.attr) {\n      if (!metadata.name) {\n        throw new Error(\n          `No name is specified for attribute ${key}. Specify it with @XmlProperty({ name: '...' }) decorator.`,\n        );\n      }\n\n      const attr = element.attributes?.[metadata.name];\n\n      if (attr) {\n        inst[key] = attr;\n      } else {\n        inst[key] = undefined;\n      }\n    } else if (metadata.chardata) {\n      inst[key] = xmlToClassInternal(element, metadata.type);\n    } else if (metadata.array) {\n      if (Array.isArray(metadata.type)) {\n        const tagNameToClassType: Map<string, any> = new Map();\n\n        metadata.type.forEach((classType) => {\n          const classTypeMetadata = registry.get(classType);\n\n          if (!classTypeMetadata) {\n            throw errUnknownClass(classType);\n          }\n\n          const tagName = classTypeMetadata.entity.name;\n\n          if (!tagName) {\n            throw new Error(\n              `No name is specified for ${classType}. Specify it with @XmlEntity({ name: '...' }) decorator.`,\n            );\n          }\n\n          tagNameToClassType.set(tagName, classType);\n        });\n\n        const possibleTagNames = [...tagNameToClassType.keys()];\n\n        const resolvedValues: any[] = [];\n\n        element.elements?.forEach((el) => {\n          if (el.name && possibleTagNames.includes(el.name)) {\n            const classType = tagNameToClassType.get(el.name);\n\n            const entity = xmlToClassInternal(el, classType);\n\n            resolvedValues.push(entity);\n          }\n        });\n\n        inst[key] = resolvedValues;\n      } else {\n        const elems =\n          element.elements?.filter((e) => e.name === metadata.name) || [];\n\n        const resolvedValues: any[] = [];\n\n        elems.forEach((el) => {\n          const entity = xmlToClassInternal(el, metadata.type as XmlType);\n\n          resolvedValues.push(entity);\n        });\n\n        inst[key] = resolvedValues;\n      }\n    } else {\n      const el = element.elements?.find((el) => el.name === metadata.name);\n\n      if (el) {\n        const value: any = xmlToClassInternal(el, metadata.type);\n\n        inst[key] = value;\n      } else {\n        inst[key] = undefined;\n      }\n    }\n  });\n\n  return inst;\n}\n\nfunction getTextForElem(el: xmljs.Element): string | undefined {\n  return el.elements?.find((e) => e.type === 'text')?.text as string;\n}\n\nexport function classToXml(\n  entity: any,\n  options?: xmljs.Options.JS2XML,\n): string {\n  const tree = buildXmlFromClassInternal(entity, '', entity.constructor);\n\n  return xmljs.js2xml(\n    {\n      declaration: { attributes: { version: '1.0', encoding: 'UTF-8' } },\n      elements: [tree],\n    },\n    options,\n  );\n}\n\nfunction buildXmlFromClassInternal(\n  entity: any,\n  name: string,\n  entityConstructor: any,\n): xmljs.Element {\n  if ([String, Number, Boolean].includes(entityConstructor)) {\n    const text = entity === null ? '' : entity?.toString();\n\n    return {\n      type: 'element',\n      name: name,\n      elements: [\n        {\n          type: 'text',\n          text,\n        },\n      ],\n    };\n  }\n\n  const meta = registry.get(entityConstructor);\n\n  if (!meta) {\n    throw errUnknownClass(entityConstructor);\n  }\n\n  const elemName = name || meta.entity.name;\n\n  if (!elemName) {\n    throw new Error(\n      `No name is specified for ${entityConstructor}. Specify it with @XmlEntity({ name: '...' }) decorator.`,\n    );\n  }\n\n  const children: xmljs.Element[] = [];\n\n  const attributes: xmljs.Attributes = {};\n\n  meta.properties.forEach((opts, classKey) => {\n    if (entity[classKey] === undefined) {\n      return;\n    }\n\n    if (opts.attr) {\n      if (!opts.name) {\n        throw new Error(\n          `No name is specified for property ${classKey}. Specify it with @XmlProperty({ name: '...' }) decorator.`,\n        );\n      }\n      attributes[opts.name] =\n        entity[classKey] === null ? '' : entity[classKey].toString();\n    } else if (opts.chardata) {\n      children.push({\n        type: 'text',\n        text: entity[classKey] === null ? '' : entity[classKey].toString(),\n      });\n    } else if (opts.array) {\n      entity[classKey]?.forEach((e: any) => {\n        // If opts.type is an array then we can't guess required class out of it.\n        // In those cases users should use class constructors (aka new MyEntity({...}))\n        // so the library can guess the class type just by looking at myEntity.constructor\n        const classConstructor = Array.isArray(opts.type)\n          ? e.constructor\n          : opts.type;\n        children.push(\n          buildXmlFromClassInternal(e, opts.name!, classConstructor),\n        );\n      });\n    } else if ([String, Number, Boolean].includes(opts.type as any)) {\n      if (!opts.name) {\n        throw new Error(\n          `No name is specified for property ${classKey}. Specify it with @XmlProperty({ name: '...' }) decorator.`,\n        );\n      }\n      children.push(\n        buildXmlFromClassInternal(entity[opts.name], opts.name, opts.type),\n      );\n    } else {\n      children.push(\n        buildXmlFromClassInternal(entity[classKey], opts.name!, opts.type),\n      );\n    }\n  });\n\n  if (meta.entity.xmlns) {\n    attributes['xmlns'] = meta.entity.xmlns;\n  }\n\n  return {\n    type: 'element',\n    name: elemName,\n    attributes,\n    elements: children,\n  };\n}\n\nfunction errUnknownClass(classConstructor: any): Error {\n  return new Error(\n    `Class ${classConstructor} not found. Make sure there is @XmlEntity({...}) decorator on it, or @XmlProperty({...}) decorator on its properties.`,\n  );\n}\n"],"names":["registry","Map","xmlToClassInternal","element","_class","String","Number","Boolean","includes","value","text","_a","el","_b","elements","find","e","type","getTextForElem","toString","parseInt","undefined","metadatas","get","Error","inst","properties","forEach","metadata","key","attr","name","attributes","chardata","array","Array","isArray","tagNameToClassType","classType","classTypeMetadata","errUnknownClass","tagName","entity","set","possibleTagNames","keys","resolvedValues","push","elems","_c","filter","_d","buildXmlFromClassInternal","entityConstructor","meta","elemName","children","opts","classKey","classConstructor","constructor","xmlns","target","propertyKey","TypeError","options","tree","xmljs","js2xml","declaration","version","encoding","xml","firstElement","xml2js","compact","alwaysArray"],"mappings":"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"}