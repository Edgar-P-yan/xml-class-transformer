{"version":3,"file":"index.umd.min.js","sources":["../src/class-metadata-registry.ts","../src/xml-class-transformer.ts","../src/decorators.ts"],"sourcesContent":["import type { AnyClass, XmlEntityOptions, XmlPropertyOptions } from './types';\n\ntype ClassMetadatas = {\n  properties: Map<string, XmlPropertyOptions>;\n  entity: XmlEntityOptions;\n};\n\nexport class ClassMetadataRegistry {\n  private registry = new Map<AnyClass, ClassMetadatas>();\n\n  setEntityOptions(clazz: AnyClass, opts: XmlEntityOptions): void {\n    const metadata = this.registry.get(clazz);\n\n    if (metadata) {\n      metadata.entity = opts;\n    } else {\n      this.registry.set(clazz, {\n        entity: opts,\n        properties: new Map(),\n      });\n    }\n  }\n\n  setPropertyOptions(\n    clazz: AnyClass,\n    propertyKey: string,\n    opts: XmlPropertyOptions,\n  ): void {\n    const metadata = this.registry.get(clazz);\n    if (metadata) {\n      metadata.properties.set(propertyKey, opts);\n    } else {\n      this.registry.set(clazz, {\n        properties: new Map([[propertyKey, opts]]),\n        entity: {},\n      });\n    }\n  }\n\n  get(clazz: AnyClass): ClassMetadatas | undefined {\n    return this.registry.get(clazz);\n  }\n}\n\nexport const registry = new ClassMetadataRegistry();\n","import xmljs from 'xml-js';\nimport { registry } from './class-metadata-registry';\nimport type { AnyClass, ClassToXmlOptions, XmlType } from './types';\n\nexport function xmlToClass<T extends AnyClass>(\n  xml: string,\n  _class: T,\n): InstanceType<T> {\n  const parsed = xmljs.xml2js(xml, {\n    compact: false,\n    alwaysArray: true,\n  }) as xmljs.Element;\n\n  const firstElement = parsed.elements?.[0];\n\n  if (!firstElement) {\n    throw new Error('No elements found in xml.');\n  }\n\n  return xmlToClassInternal(firstElement, _class);\n}\n\nfunction xmlToClassInternal(element: xmljs.Element, _class: any): any {\n  if ([String, Number, Boolean].includes(_class)) {\n    let value: unknown = undefined;\n\n    const text = getTextForElem(element)?.toString();\n\n    if (_class === String) {\n      value = text;\n    } else if (_class === Number) {\n      value = text ? parseInt(text, 10) : undefined;\n    } else if (_class === Boolean) {\n      value = text ? text === 'true' : undefined;\n    }\n\n    return value;\n  }\n\n  const metadatas = registry.get(_class);\n\n  if (!metadatas) {\n    throw new Error('Unknown class ' + _class);\n  }\n\n  const inst = new _class();\n\n  metadatas.properties.forEach((metadata, key) => {\n    if (metadata.attr) {\n      if (!metadata.name) {\n        throw new Error(\n          `No name is specified for attribute ${key}. Specify it with @XmlProperty({ name: '...' }) decorator.`,\n        );\n      }\n\n      const attr = element.attributes?.[metadata.name];\n\n      if (attr) {\n        inst[key] = attr;\n      } else {\n        inst[key] = undefined;\n      }\n    } else if (metadata.chardata) {\n      inst[key] = xmlToClassInternal(element, metadata.type);\n    } else if (metadata.array) {\n      if (Array.isArray(metadata.type)) {\n        const tagNameToClassType: Map<string, any> = new Map();\n\n        metadata.type.forEach((classType) => {\n          const classTypeMetadata = registry.get(classType);\n\n          if (!classTypeMetadata) {\n            throw errUnknownClass(classType);\n          }\n\n          const tagName = classTypeMetadata.entity.name;\n\n          if (!tagName) {\n            throw new Error(\n              `No name is specified for ${classType}. Specify it with @XmlEntity({ name: '...' }) decorator.`,\n            );\n          }\n\n          tagNameToClassType.set(tagName, classType);\n        });\n\n        const possibleTagNames = [...tagNameToClassType.keys()];\n\n        const resolvedValues: any[] = [];\n\n        element.elements?.forEach((el) => {\n          if (el.name && possibleTagNames.includes(el.name)) {\n            const classType = tagNameToClassType.get(el.name);\n\n            const entity = xmlToClassInternal(el, classType);\n\n            resolvedValues.push(entity);\n          }\n        });\n\n        inst[key] = resolvedValues;\n      } else {\n        const elems =\n          element.elements?.filter((e) => e.name === metadata.name) || [];\n\n        const resolvedValues: any[] = [];\n\n        elems.forEach((el) => {\n          const entity = xmlToClassInternal(el, metadata.type as XmlType);\n\n          resolvedValues.push(entity);\n        });\n\n        inst[key] = resolvedValues;\n      }\n    } else {\n      const el = element.elements?.find((el) => el.name === metadata.name);\n\n      if (el) {\n        const value: any = xmlToClassInternal(el, metadata.type);\n\n        inst[key] = value;\n      } else {\n        inst[key] = undefined;\n      }\n    }\n  });\n\n  return inst;\n}\n\nfunction getTextForElem(el: xmljs.Element): string | undefined {\n  return el.elements?.find((e) => e.type === 'text')?.text as string;\n}\n\nexport function classToXml(entity: any, options?: ClassToXmlOptions): string {\n  const tree = classToXmlInternal(entity, '', entity.constructor);\n\n  const rootElem: xmljs.Element = { elements: [tree] };\n\n  if (options?.declaration !== false) {\n    if (\n      typeof options?.declaration === 'object' &&\n      options?.declaration !== null\n    ) {\n      rootElem.declaration = options.declaration;\n    } else {\n      rootElem.declaration = {\n        attributes: { version: '1.0', encoding: 'UTF-8' },\n      };\n    }\n  }\n\n  return xmljs.js2xml(rootElem, options);\n}\n\nfunction classToXmlInternal(\n  entity: any,\n  name: string,\n  entityConstructor: any,\n): xmljs.Element {\n  if ([String, Number, Boolean].includes(entityConstructor)) {\n    const text = entity === null ? '' : entity?.toString();\n\n    return {\n      type: 'element',\n      name: name,\n      elements: [\n        {\n          type: 'text',\n          text,\n        },\n      ],\n    };\n  }\n\n  const meta = registry.get(entityConstructor);\n\n  if (!meta) {\n    throw errUnknownClass(entityConstructor);\n  }\n\n  const elemName = name || meta.entity.name;\n\n  if (!elemName) {\n    throw new Error(\n      `No name is specified for ${entityConstructor}. Specify it with @XmlEntity({ name: '...' }) decorator.`,\n    );\n  }\n\n  const children: xmljs.Element[] = [];\n\n  const attributes: xmljs.Attributes = {};\n\n  meta.properties.forEach((opts, classKey) => {\n    if (entity[classKey] === undefined) {\n      return;\n    }\n\n    if (opts.attr) {\n      if (!opts.name) {\n        throw new Error(\n          `No name is specified for property ${classKey}. Specify it with @XmlProperty({ name: '...' }) decorator.`,\n        );\n      }\n      attributes[opts.name] =\n        entity[classKey] === null ? '' : entity[classKey].toString();\n    } else if (opts.chardata) {\n      children.push({\n        type: 'text',\n        text: entity[classKey] === null ? '' : entity[classKey].toString(),\n      });\n    } else if (opts.array) {\n      entity[classKey]?.forEach((e: any) => {\n        // If opts.type is an array then we can't guess required class out of it.\n        // In those cases users should use class constructors (aka new MyEntity({...}))\n        // so the library can guess the class type just by looking at myEntity.constructor\n        const classConstructor = Array.isArray(opts.type)\n          ? e.constructor\n          : opts.type;\n        children.push(classToXmlInternal(e, opts.name!, classConstructor));\n      });\n    } else if ([String, Number, Boolean].includes(opts.type as any)) {\n      if (!opts.name) {\n        throw new Error(\n          `No name is specified for property ${classKey}. Specify it with @XmlProperty({ name: '...' }) decorator.`,\n        );\n      }\n      children.push(\n        classToXmlInternal(entity[opts.name], opts.name, opts.type),\n      );\n    } else {\n      children.push(\n        classToXmlInternal(entity[classKey], opts.name!, opts.type),\n      );\n    }\n  });\n\n  if (meta.entity.xmlns) {\n    attributes['xmlns'] = meta.entity.xmlns;\n  }\n\n  return {\n    type: 'element',\n    name: elemName,\n    attributes,\n    elements: children,\n  };\n}\n\nfunction errUnknownClass(classConstructor: any): Error {\n  return new Error(\n    `Class ${classConstructor} not found. Make sure there is @XmlEntity({...}) decorator on it, or @XmlProperty({...}) decorator on its properties.`,\n  );\n}\n","import { registry } from './class-metadata-registry';\nimport type { XmlEntityOptions, XmlPropertyOptions } from './types';\n\n/**\n * Class decorator\n */\nexport function XmlEntity(opts?: XmlEntityOptions): ClassDecorator {\n  return (target: any): any => {\n    opts = opts || {};\n\n    opts.name = opts.name || target.name;\n\n    if (!opts.name) {\n      throw new Error(\n        `Failed to get the element name for class ${target}. Specify it with @XmlEntity({ name: '...' }) decorator.`,\n      );\n    }\n\n    registry.setEntityOptions(target, opts);\n\n    return target;\n  };\n}\n\n/**\n * Class property decorator\n */\nexport function XmlProperty(opts: XmlPropertyOptions): PropertyDecorator {\n  return (target: { constructor: any }, propertyKey: string | symbol): void => {\n    opts.name === opts.name || propertyKey;\n\n    if (typeof propertyKey !== 'string') {\n      throw new TypeError(\n        `Can't use @XmlProperty({...}) decorator on symbol property at ${\n          target.constructor.name\n        }#${propertyKey.toString()}`,\n      );\n    }\n\n    registry.setPropertyOptions(target.constructor, propertyKey, opts);\n  };\n}\n"],"names":["registry","constructor","this","Map","setEntityOptions","clazz","opts","metadata","get","entity","set","properties","setPropertyOptions","propertyKey","xmlToClassInternal","element","_class","String","Number","Boolean","includes","value","text","_a","el","_b","elements","find","e","type","getTextForElem","toString","parseInt","undefined","metadatas","Error","inst","forEach","key","attr","name","attributes","chardata","array","Array","isArray","tagNameToClassType","classType","classTypeMetadata","errUnknownClass","tagName","possibleTagNames","keys","resolvedValues","push","elems","_c","filter","_d","classToXmlInternal","entityConstructor","meta","elemName","children","classKey","classConstructor","xmlns","target","TypeError","options","rootElem","declaration","version","encoding","xmljs","js2xml","xml","firstElement","xml2js","compact","alwaysArray"],"mappings":"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"}