{"version":3,"file":"index.mjs","sources":["../src/index.ts"],"sourcesContent":["import xmljs from 'xml-js';\n\nexport type AnyClass = { new (): any };\n\nexport type XmlType = typeof String | typeof Number | typeof Boolean | AnyClass;\n\nexport interface XmlEntityOptions {\n  /**\n   * xmlns attribute value.\n   * This is just a shortcut for @XmlAttribute({ name: 'xmlns', value: '...' }) property decorator.\n   */\n  xmlns?: string;\n\n  /**\n   * XML element name.\n   * If not specified, the class name will be used.\n   */\n  name?: string;\n}\n\nexport interface XmlPropertyOptions {\n  /**\n   * Specify primitive type or class type for parsing and serializing.\n   * @example\n   * { type: String }\n   *\n   * You can also specify multiple classes, then the one whose name matches the element name will be selected.\n   * @example\n   * { type: [Version, DeleteMarker] }\n   */\n  type: XmlType | XmlType[];\n\n  /**\n   * If true, the property will be parsed and serialized as an array.\n   * Not compatible with `attr` and `chardata` options.\n   */\n  array?: boolean;\n\n  /**\n   * XML element name.\n   * If not specified, the property name will be used.\n   * It is highly recommended to specify it explicitly.\n   *\n   * Not compatible with `chardata` options.\n   */\n  name?: string | undefined;\n\n  /**\n   * If true, the property will be parsed and serialized as an attribute.\n   */\n  attr?: boolean;\n\n  /**\n   * If true, the property will be parsed and serialized as a character data.\n   * Not compatible with `array` and `attr` options.\n   *\n   * It's only useful when you parse elements with a text node and no attributes.\n   *\n   * @example\n   * *XmlEntity({ name: 'Comment' })\n   * class Comment {\n   *  *XmlProperty({ chardata: true })\n   *  text: string;\n   *\n   *  *XmlProperty({ name: 'lang', attr: true })\n   *  lenguage: string;\n   *\n   *  constructor(d?: Comment) {\n   *   Object.assign(this, d || {});\n   *  }\n   * }\n   *\n   * classToXml(\n   *  new Comment({\n   *    text: 'This is awesome',\n   *    lenguage: 'en',\n   *  })\n   * )\n   *\n   * // Output:\n   * <Comment lang=\"en\">This is awesome</Comment>\n   */\n  chardata?: boolean;\n}\n\ntype ClassMetadatas = {\n  properties: Map<string, XmlPropertyOptions>;\n  entity: XmlEntityOptions;\n};\n\nconst registry: Map<AnyClass, ClassMetadatas> = new Map();\n\n/**\n * Class decorator\n */\nexport function XmlEntity(opts?: XmlEntityOptions): ClassDecorator {\n  return (target: any): any => {\n    opts = opts || {};\n\n    opts.name = opts.name || target.name;\n\n    if (!opts.name) {\n      throw new Error(\n        `Failed to get the element name for class ${target}. Specify it with @XmlEntity({ name: '...' }) decorator.`,\n      );\n    }\n\n    const metadata = registry.get(target);\n\n    if (metadata) {\n      metadata.entity = opts;\n    } else {\n      registry.set(target, {\n        entity: opts,\n        properties: new Map(),\n      });\n    }\n\n    return target;\n  };\n}\n\n/**\n * Class property decorator\n */\nexport function XmlProperty(opts: XmlPropertyOptions): PropertyDecorator {\n  return (target: { constructor: any }, propertyKey: string | symbol): void => {\n    opts.name === opts.name || propertyKey;\n\n    if (typeof propertyKey !== 'string') {\n      throw new TypeError(\n        `Can't use @XmlProperty({...}) decorator on symbol property at ${\n          target.constructor.name\n        }#${propertyKey.toString()}`,\n      );\n    }\n\n    const metadata = registry.get(target.constructor);\n    if (metadata) {\n      metadata.properties.set(propertyKey, opts);\n    } else {\n      registry.set(target.constructor, {\n        properties: new Map([[propertyKey, opts]]),\n        entity: {},\n      });\n    }\n  };\n}\n\nexport function xmlToClass<T extends AnyClass>(\n  xml: string,\n  _class: T,\n): InstanceType<T> {\n  const parsed = xmljs.xml2js(xml, {\n    compact: false,\n    alwaysArray: true,\n  }) as xmljs.Element;\n\n  const firstElement = parsed.elements?.[0];\n\n  if (!firstElement) {\n    throw new Error('No elements found in xml.');\n  }\n\n  return xmlToClassInternal(firstElement, _class);\n}\n\nfunction xmlToClassInternal(element: xmljs.Element, _class: any): any {\n  if ([String, Number, Boolean].includes(_class)) {\n    let value: unknown = undefined;\n\n    const text = getTextForElem(element)?.toString();\n\n    if (_class === String) {\n      value = text;\n    } else if (_class === Number) {\n      value = text ? parseInt(text, 10) : undefined;\n    } else if (_class === Boolean) {\n      value = text ? text === 'true' : undefined;\n    }\n\n    return value;\n  }\n\n  const metadatas = registry.get(_class);\n\n  if (!metadatas) {\n    throw new Error('Unknown class ' + _class);\n  }\n\n  const inst = new _class();\n\n  metadatas.properties.forEach((metadata, key) => {\n    if (metadata.attr) {\n      if (!metadata.name) {\n        throw new Error(\n          `No name is specified for attribute ${key}. Specify it with @XmlProperty({ name: '...' }) decorator.`,\n        );\n      }\n\n      const attr = element.attributes?.[metadata.name];\n\n      if (attr) {\n        inst[key] = attr;\n      } else {\n        inst[key] = undefined;\n      }\n    } else if (metadata.chardata) {\n      inst[key] = xmlToClassInternal(element, metadata.type);\n    } else if (metadata.array) {\n      if (Array.isArray(metadata.type)) {\n        const tagNameToClassType: Map<string, any> = new Map();\n\n        metadata.type.forEach((classType) => {\n          const classTypeMetadata = registry.get(classType);\n\n          if (!classTypeMetadata) {\n            throw errUnknownClass(classType);\n          }\n\n          const tagName = classTypeMetadata.entity.name;\n\n          if (!tagName) {\n            throw new Error(\n              `No name is specified for ${classType}. Specify it with @XmlEntity({ name: '...' }) decorator.`,\n            );\n          }\n\n          tagNameToClassType.set(tagName, classType);\n        });\n\n        const possibleTagNames = [...tagNameToClassType.keys()];\n\n        const resolvedValues: any[] = [];\n\n        element.elements?.forEach((el) => {\n          if (el.name && possibleTagNames.includes(el.name)) {\n            const classType = tagNameToClassType.get(el.name);\n\n            const entity = xmlToClassInternal(el, classType);\n\n            resolvedValues.push(entity);\n          }\n        });\n\n        inst[key] = resolvedValues;\n      } else {\n        const elems =\n          element.elements?.filter((e) => e.name === metadata.name) || [];\n\n        const resolvedValues: any[] = [];\n\n        elems.forEach((el) => {\n          const entity = xmlToClassInternal(el, metadata.type as XmlType);\n\n          resolvedValues.push(entity);\n        });\n\n        inst[key] = resolvedValues;\n      }\n    } else {\n      const el = element.elements?.find((el) => el.name === metadata.name);\n\n      if (el) {\n        const value: any = xmlToClassInternal(el, metadata.type);\n\n        inst[key] = value;\n      } else {\n        inst[key] = undefined;\n      }\n    }\n  });\n\n  return inst;\n}\n\nfunction getTextForElem(el: xmljs.Element): string | undefined {\n  return el.elements?.find((e) => e.type === 'text')?.text as string;\n}\n\nexport function classToXml(\n  entity: any,\n  options?: xmljs.Options.JS2XML,\n): string {\n  const tree = buildXmlFromClassInternal(entity, '', entity.constructor);\n\n  return xmljs.js2xml(\n    {\n      declaration: { attributes: { version: '1.0', encoding: 'UTF-8' } },\n      elements: [tree],\n    },\n    options,\n  );\n}\n\nfunction buildXmlFromClassInternal(\n  entity: any,\n  name: string,\n  entityConstructor: any,\n): xmljs.Element {\n  if ([String, Number, Boolean].includes(entityConstructor)) {\n    const text = entity === null ? '' : entity?.toString();\n\n    return {\n      type: 'element',\n      name: name,\n      elements: [\n        {\n          type: 'text',\n          text,\n        },\n      ],\n    };\n  }\n\n  const meta = registry.get(entityConstructor);\n\n  if (!meta) {\n    throw errUnknownClass(entityConstructor);\n  }\n\n  const elemName = name || meta.entity.name;\n\n  if (!elemName) {\n    throw new Error(\n      `No name is specified for ${entityConstructor}. Specify it with @XmlEntity({ name: '...' }) decorator.`,\n    );\n  }\n\n  const children: xmljs.Element[] = [];\n\n  const attributes: xmljs.Attributes = {};\n\n  meta.properties.forEach((opts, classKey) => {\n    if (entity[classKey] === undefined) {\n      return;\n    }\n\n    if (opts.attr) {\n      if (!opts.name) {\n        throw new Error(\n          `No name is specified for property ${classKey}. Specify it with @XmlProperty({ name: '...' }) decorator.`,\n        );\n      }\n      attributes[opts.name] =\n        entity[classKey] === null ? '' : entity[classKey].toString();\n    } else if (opts.chardata) {\n      children.push({\n        type: 'text',\n        text: entity[classKey] === null ? '' : entity[classKey].toString(),\n      });\n    } else if (opts.array) {\n      entity[classKey]?.forEach((e: any) => {\n        // If opts.type is an array then we can't guess required class out of it.\n        // In those cases users should use class constructors (aka new MyEntity({...}))\n        // so the library can guess the class type just by looking at myEntity.constructor\n        const classConstructor = Array.isArray(opts.type)\n          ? e.constructor\n          : opts.type;\n        children.push(\n          buildXmlFromClassInternal(e, opts.name!, classConstructor),\n        );\n      });\n    } else if ([String, Number, Boolean].includes(opts.type as any)) {\n      if (!opts.name) {\n        throw new Error(\n          `No name is specified for property ${classKey}. Specify it with @XmlProperty({ name: '...' }) decorator.`,\n        );\n      }\n      children.push(\n        buildXmlFromClassInternal(entity[opts.name], opts.name, opts.type),\n      );\n    } else {\n      children.push(\n        buildXmlFromClassInternal(entity[classKey], opts.name!, opts.type),\n      );\n    }\n  });\n\n  if (meta.entity.xmlns) {\n    attributes['xmlns'] = meta.entity.xmlns;\n  }\n\n  return {\n    type: 'element',\n    name: elemName,\n    attributes,\n    elements: children,\n  };\n}\n\nfunction errUnknownClass(classConstructor: any): Error {\n  return new Error(\n    `Class ${classConstructor} not found. Make sure there is @XmlEntity({...}) decorator on it, or @XmlProperty({...}) decorator on its properties.`,\n  );\n}\n"],"names":[],"mappings":"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"}