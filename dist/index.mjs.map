{"version":3,"file":"index.mjs","sources":["../src/class-metadata-registry.ts","../src/common.ts","../src/transform-class-to-xml.ts","../src/transform-xml-to-class.ts","../src/decorators.ts"],"sourcesContent":["import { InternalXmlPropertyOptions } from './internal-types';\nimport type { XmlClass, XmlElemOptions } from './types';\n\ntype ClassMetadatas = {\n  properties: Map<string, InternalXmlPropertyOptions>;\n  entity: XmlElemOptions;\n};\n\nexport class ClassMetadataRegistry {\n  private registry = new Map<XmlClass, ClassMetadatas>();\n\n  setEntityOptions(xClass: XmlClass, opts: XmlElemOptions): void {\n    const metadata = this.registry.get(xClass);\n\n    if (metadata) {\n      metadata.entity = opts;\n    } else {\n      this.registry.set(xClass, {\n        entity: opts,\n        properties: new Map(),\n      });\n    }\n  }\n\n  setPropertyOptions(\n    xClass: XmlClass,\n    propertyKey: string,\n    opts: InternalXmlPropertyOptions,\n  ): void {\n    const metadata = this.getOrCreate(xClass);\n\n    if (opts.comments) {\n      for (const [searchingPropKey, searchingOpts] of metadata.properties) {\n        if (searchingOpts.comments) {\n          throw new Error(\n            `xml-class-transformer: only one @XmlComment() decorator is allowed per class. ` +\n              `Can not define @XmlComment() decorator for  ` +\n              `${xClass.name}#${propertyKey} since it's already used for ` +\n              `${xClass.name}#${searchingPropKey}.`,\n          );\n        }\n      }\n    }\n\n    if (opts.name) {\n      for (const [searchingPropKey, searchingOpts] of metadata.properties) {\n        if (searchingOpts.name === opts.name) {\n          throw new Error(\n            `xml-class-transformer: can't use XML element name defined in ` +\n              `{ name: ${JSON.stringify(opts.name)} } for ` +\n              `${xClass.name}#${propertyKey} since it's already used for ` +\n              `${xClass.name}#${searchingPropKey}. Change it to something else.`,\n          );\n        }\n\n        // TODO: maybe support multiple chardata for multiple child text nodes inside an xml element.\n        // each of those chardata properties whould match the text node at the same position as the property itself.\n        // The same goes for not yet implemented comments and cdata.\n        if (opts.chardata && searchingOpts.chardata) {\n          throw new Error(\n            `xml-class-transformer: an XML element can have only one chardata property. ` +\n              `Both ${xClass.name}#${propertyKey} and ${xClass.name}#${searchingOpts.name} ` +\n              `are defined as chardata, which is not valid.`,\n          );\n        }\n      }\n    }\n\n    metadata.properties.set(propertyKey, opts);\n  }\n\n  private getOrCreate(xClass: XmlClass): ClassMetadatas {\n    const existing = this.registry.get(xClass);\n    if (existing) {\n      return existing;\n    } else {\n      const newMetadatas: ClassMetadatas = {\n        entity: {\n          name: xClass?.name,\n        },\n        properties: new Map(),\n      };\n\n      this.registry.set(xClass, newMetadatas);\n\n      return newMetadatas;\n    }\n  }\n\n  get(xClass: XmlClass): ClassMetadatas | undefined {\n    return this.registry.get(xClass);\n  }\n}\n\nexport const registry = new ClassMetadataRegistry();\n","import { XmlPrimitiveType, XmlType } from './types';\n\nexport function errUnknownClass(classConstructor: any): Error {\n  return new Error(\n    `xml-class-transformer: class \"${classConstructor}\" not found. Make sure there is a @XmlElem({...}) ` +\n      `decorator on it, or XmlChildElem, XmlAttribute, XmlChardata or XmlComments decorator on its properties.`,\n  );\n}\n\nexport function serializeUnionForLog(union: any[]): string {\n  return '[' + union.map((t) => t?.name ?? `${union}`).join(', ') + ']';\n}\n\nexport function isPrimitiveType(type: XmlType): type is XmlPrimitiveType {\n  return (\n    type === String || type === Number || type === BigInt || type === Boolean\n  );\n}\n","import xmljs from 'xml-js-v2';\nimport { registry } from './class-metadata-registry';\nimport { ClassToXmlOptions, XmlType } from './types';\nimport { errUnknownClass, isPrimitiveType } from './common';\n\nexport function classToXml(entity: any, options?: ClassToXmlOptions): string {\n  const tree = classToXmlInternal(entity, '', entity.constructor);\n\n  const rootElem: xmljs.Element = { elements: [tree] };\n\n  if (options?.declaration !== false) {\n    if (\n      typeof options?.declaration === 'object' &&\n      options?.declaration !== null\n    ) {\n      rootElem.declaration = options.declaration;\n    } else {\n      rootElem.declaration = {\n        attributes: { version: '1.0', encoding: 'UTF-8' },\n      };\n    }\n  }\n\n  return xmljs.js2xml(rootElem, options);\n}\n\nfunction classToXmlInternal(\n  entity: any,\n  name: string | undefined,\n  entityConstructor: XmlType,\n): xmljs.Element {\n  if (isPrimitiveType(entityConstructor)) {\n    const text = entity === null ? '' : `${entity}`;\n\n    return {\n      type: 'element',\n      name: name!,\n      elements: [\n        {\n          type: 'text',\n          text,\n        },\n      ],\n    };\n  }\n\n  const meta = registry.get(entityConstructor);\n\n  if (!meta) {\n    throw errUnknownClass(entityConstructor);\n  }\n\n  const elemName = name || meta.entity.name;\n\n  if (!elemName) {\n    throw new Error(\n      `xml-class-transformer: no XML name is specified for the class \"${entityConstructor?.name}\". Specify it with the @XmlElem({ name: '...' }) decorator.`,\n    );\n  }\n\n  const children: xmljs.Element[] = [];\n\n  const attributes: xmljs.Attributes = {};\n\n  meta.properties.forEach((opts, classKey) => {\n    // Do not emit attribute if value is undefined,\n    if (entity[classKey] === undefined) {\n      return;\n    }\n\n    if (opts.comments) {\n      if (Array.isArray(entity[classKey])) {\n        for (const comment of entity[classKey]) {\n          children.push({\n            type: 'comment',\n            comment:\n              comment === null || comment === undefined ? '' : `${comment}`,\n          });\n        }\n      }\n    } else if (opts.attr) {\n      if (!opts.name) {\n        throw new Error(\n          `xml-class-transformer: no name is specified for the property ${entityConstructor?.name}#${classKey}. Specify it with the @XmlAttribute({ name: '...' }) decorator.`,\n        );\n      }\n\n      attributes[opts.name] =\n        entity[classKey] === null ? '' : `${entity[classKey]}`;\n    } else if (opts.chardata) {\n      children.push({\n        type: 'text',\n        text: entity[classKey] === null ? '' : `${entity[classKey]}`,\n      });\n    } else if (opts.array) {\n      if (entity[classKey] === null) {\n        return;\n      }\n\n      entity[classKey]?.forEach((e: any) => {\n        // Do not process null and undefined values in the array.\n        // When we impl support for primitive unions maybe this should change\n        if (!e) {\n          return;\n        }\n\n        // If it is a union then we can't guess required class out of it.\n        // In those cases users should give to the library actual class instances (aka new MyEntity({...}))\n        // so the library can guess the class type just by looking at the myEntity.constructor\n        const classConstructor = opts.union ? e.constructor : opts.type!();\n        // The opts.name will be undefined if !!opts.union, but thats ok.\n        children.push(classToXmlInternal(e, opts.name, classConstructor));\n      });\n    } else if (opts.type && isPrimitiveType(opts.type())) {\n      if (!opts.name) {\n        throw new Error(\n          `xml-class-transformer: no name is specified for property ${entityConstructor?.name}#${classKey}. Specify it with @XmlChildElem({ name: '...' }) decorator.`,\n        );\n      }\n      children.push(\n        classToXmlInternal(entity[classKey], opts.name, opts.type()),\n      );\n    } else if (opts.union) {\n      // should work with primitive types also\n      const classConstructor = entity[classKey].constructor;\n\n      children.push(\n        classToXmlInternal(entity[classKey], undefined, classConstructor),\n      );\n    } else {\n      // If null then just skip this embedded element for the current impl\n      // TODO: maybe non array unions are borken\n      if (entity[classKey] !== null) {\n        children.push(\n          classToXmlInternal(\n            entity[classKey],\n            opts.name,\n            opts.union ? entity[classKey].constructor : opts.type!(),\n          ),\n        );\n      }\n    }\n  });\n\n  if (meta.entity.xmlns) {\n    attributes['xmlns'] = meta.entity.xmlns;\n  }\n\n  return {\n    type: 'element',\n    name: elemName,\n    attributes,\n    elements: children,\n  };\n}\n","import xmljs from 'xml-js-v2';\nimport { registry } from './class-metadata-registry';\nimport type { XmlClass, XmlPrimitiveType, XmlType } from './types';\nimport { errUnknownClass, isPrimitiveType } from './common';\n\nexport function xmlToClass<T extends XmlClass>(\n  xml: string,\n  _class: T,\n): InstanceType<T> {\n  const parsed = xmljs.xml2js(xml, {\n    compact: false,\n    alwaysArray: true,\n  }) as xmljs.Element;\n\n  const firstElement = parsed.elements?.[0];\n\n  if (!firstElement) {\n    throw new Error('No elements found in xml.');\n  }\n\n  return xmlToClassInternal(firstElement, _class);\n}\n\nfunction xmlToClassInternal(element: xmljs.Element, _class: XmlType): any {\n  if (isPrimitiveType(_class)) {\n    const text = getChardataFromElem(element);\n\n    return parsePrimitive(text, _class);\n  }\n\n  const metadatas = registry.get(_class);\n\n  if (!metadatas) {\n    throw new Error('Unknown class ' + _class);\n  }\n\n  const inst = new _class();\n\n  metadatas.properties.forEach((metadata, key) => {\n    if (metadata.comments) {\n      const commentsAccumulated: string[] = [];\n\n      for (const childElem of element.elements || []) {\n        if (childElem.type === 'comment') {\n          commentsAccumulated.push(childElem.comment || '');\n        }\n      }\n\n      inst[key] = commentsAccumulated;\n    } else if (metadata.attr) {\n      if (!metadata.name) {\n        throw new Error(\n          `xml-class-transformer: no name is specified for attribute ${key}. Specify it with @XmlAttribute({ name: '...' }) decorator.`,\n        );\n      }\n\n      const attr = element.attributes?.[metadata.name];\n\n      if (attr !== undefined && attr !== null) {\n        inst[key] = parsePrimitive(attr, metadata.type!() as XmlPrimitiveType);\n      } else {\n        // If the attribute property is undefined - it means\n        // that the attribute was not present in the xml.\n        inst[key] = undefined;\n      }\n    } else if (metadata.chardata) {\n      inst[key] = xmlToClassInternal(element, metadata.type!());\n    } else if (metadata.array) {\n      if (metadata.union) {\n        // TODO: optimize and cache this map:\n        const tagNameToClassType: Map<string, any> = new Map();\n\n        metadata.union().forEach((classType) => {\n          const classTypeMetadata = registry.get(classType);\n\n          if (!classTypeMetadata) {\n            throw errUnknownClass(classType);\n          }\n\n          const tagName = classTypeMetadata.entity.name;\n\n          if (!tagName) {\n            throw new Error(\n              `xml-class-transformer: no name is specified for ${classType}. Specify it with the @XmlElem({ name: '...' }) decorator.`,\n            );\n          }\n\n          tagNameToClassType.set(tagName, classType);\n        });\n\n        const possibleTagNames = [...tagNameToClassType.keys()];\n\n        const resolvedValues: any[] = [];\n\n        element.elements?.forEach((el) => {\n          if (el.name && possibleTagNames.includes(el.name)) {\n            const classType = tagNameToClassType.get(el.name);\n\n            const entity = xmlToClassInternal(el, classType);\n\n            resolvedValues.push(entity);\n          }\n        });\n\n        inst[key] = resolvedValues;\n      } else {\n        const elems =\n          element.elements?.filter((e) => e.name === metadata.name) || [];\n\n        const resolvedValues: any[] = [];\n\n        elems.forEach((el) => {\n          const entity = xmlToClassInternal(el, metadata.type!() as XmlType);\n\n          resolvedValues.push(entity);\n        });\n\n        inst[key] = resolvedValues;\n      }\n    } else if (metadata.union) {\n      // TODO: optimize and cache this map:\n      const tagNameToClassType: Map<string, any> = new Map();\n\n      metadata.union().forEach((classType) => {\n        const classTypeMetadata = registry.get(classType);\n\n        if (!classTypeMetadata) {\n          throw errUnknownClass(classType);\n        }\n\n        const tagName = classTypeMetadata.entity.name;\n\n        if (!tagName) {\n          throw new Error(\n            `xml-class-transformer: no name is specified for ${classType}. Specify it with the @XmlElem({ name: '...' }) decorator.`,\n          );\n        }\n\n        tagNameToClassType.set(tagName, classType);\n      });\n\n      const matchingXmlElement = element.elements?.find((el) => {\n        return el.name && tagNameToClassType.has(el.name);\n      });\n\n      inst[key] = matchingXmlElement\n        ? xmlToClassInternal(\n            matchingXmlElement,\n            tagNameToClassType.get(matchingXmlElement.name!)!,\n          )\n        : undefined;\n    } else {\n      const el = element.elements?.find((el) => el.name === metadata.name);\n\n      if (el) {\n        const value: any = xmlToClassInternal(el, metadata.type!());\n\n        inst[key] = value;\n      } else {\n        inst[key] = undefined;\n      }\n    }\n  });\n\n  return inst;\n}\n\nfunction getChardataFromElem(el: xmljs.Element): string {\n  let chardata = '';\n\n  for (const child of el.elements || []) {\n    if (child.type === 'text' && child.text) {\n      chardata += (child.text as string) || '';\n    }\n  }\n\n  return chardata;\n}\n\nfunction parsePrimitive(\n  // Support numbers also\n  value: string | number | undefined,\n  classConstructor: XmlPrimitiveType | undefined,\n): string | number | bigint | boolean | null | undefined {\n  let result: string | number | bigint | boolean | null | undefined = undefined;\n\n  if (value === undefined) {\n    result = undefined;\n  } else {\n    const castToStr = `${value}`;\n\n    if (classConstructor === Number) {\n      result =\n        // parse empty strings to nulls when the specified type is Number\n        // bacause there is no convenient way to represent an empty string as a number,\n        // there is an idea to convert them to 0, but it's an implicit and non obvious behaviour.\n        // Maybe a better idea would be to convert them to NaN just as parseFloat does.\n        castToStr === '' ? null : parseFloat(castToStr);\n    } else if (classConstructor === BigInt) {\n      result = castToStr === '' ? null : BigInt(castToStr);\n    } else if (classConstructor === Boolean) {\n      result = castToStr === '' ? null : castToStr === 'true';\n    } else {\n      // classConstructor is String or any other type, then fallback to String:\n      // In case of the string dont cast empty strings to nulls\n      result = castToStr;\n    }\n  }\n\n  return result;\n}\n","import { registry } from './class-metadata-registry';\nimport { isPrimitiveType, serializeUnionForLog } from './common';\nimport { InternalXmlPropertyOptions } from './internal-types';\nimport type {\n  XmlAttributeOptions,\n  XmlChardataOptions,\n  XmlChildElemOptions,\n  XmlElemOptions,\n} from './types';\n\n/**\n * A class decorator.\n * It can be omitted, but only if at least one Xml* property decorator is used on it's properties.\n *\n * @example\n * \\@XmlElem()\n * class EmptyXmlElement {}\n *\n * \\@XmlElem({ name: 'some-xml-element' })\n * class SomeXmlElement {\n *   \\@XmlChildElem()\n *   child: string;\n * }\n *\n * \\@XmlElem({ xmlns: 'http://s3.amazonaws.com/doc/2006-03-01/' })\n * class SomeXmlElement {\n *   \\@XmlChildElem()\n *   child: string;\n * }\n */\nexport function XmlElem(opts?: XmlElemOptions): ClassDecorator {\n  return (target: any): any => {\n    opts = opts || {};\n\n    opts.name = opts.name || target.name;\n\n    if (!opts.name) {\n      throw new Error(\n        `xml-class-transformer: Failed to get the element name for class ${target}. Specify it with @XmlElem({ name: '...' }) decorator.`,\n      );\n    }\n\n    registry.setEntityOptions(target, opts);\n\n    return target;\n  };\n}\n\n/**\n * Class property decorator.\n *\n * @example\n * class SomeElement {\n *   \\@XmlChildElem({ type: () => String })\n *   stringElem: string;\n *\n *   \\@XmlChildElem({ name: 'someOtherName', type: () => Number })\n *   numberElem: string;\n *\n *   \\@XmlChildElem({ type: () => NestedElem })\n *   nestedElem: NestedElem;\n * }\n */\nexport function XmlChildElem(opts: XmlChildElemOptions): PropertyDecorator {\n  return propertyDecoratorFactory('XmlChildElem', opts);\n}\n\n/**\n * Class property decorator.\n * For more details on options see {@link XmlAttributeOptions}\n *\n * @example\n * // a basic example\n * class SomeXmlElement {\n *   \\@XmlAttribute({ name: 'attributeName', type: () => String })\n *   attributeName: string;\n * }\n */\nexport function XmlAttribute(opts: XmlAttributeOptions): PropertyDecorator {\n  return propertyDecoratorFactory('XmlAttribute', {\n    ...opts,\n    attr: true,\n  });\n}\n\n/**\n * This decorator, when used on a class property, collects all the comments\n * from the provided XML, turns them into an array of strings and puts them into\n * that property. And vice-versa: at serialization that array of strings gets serialized to set of comments\n * in the resulting XML.\n *\n * @example\n * ```ts\n * class SomeElement {\n *   \\@XmlComments()\n *   comments?: string[];\n * }\n *\n * classToXml(\n *   new SomeElement({\n *     comments: ['some comment', 'some other comment']\n *   })\n * )\n * ```\n *\n * Output:\n * ```xml\n * <SomeElement>\n *   <!-- some comment -->\n *   <!-- some other comment -->\n * </SomeElement>\n *\n * ```\n */\nexport function XmlComments(): PropertyDecorator {\n  return (target: { constructor: any }, propertyKey: string | symbol): void => {\n    if (typeof propertyKey !== 'string') {\n      // Dont support symbols for now\n      throw new TypeError(\n        `xml-class-transformer: Can't use @XmlComments({...}) decorator on a symbol property ` +\n          `at ${target.constructor.name}#${propertyKey.toString()}`,\n      );\n    }\n\n    registry.setPropertyOptions(target.constructor, propertyKey, {\n      comments: true,\n    });\n  };\n}\n\n/**\n * The property will be parsed and serialized as a character data.\n * The \"type\" parameter can only be a primitive type: String, Number, Boolean.\n *\n * ```ts\n * \\@XmlElem({ name: 'Comment' })\n * class Comment {\n *   \\@XmlChardata({ type: () => String })\n *   text: string;\n *\n *   \\@XmlAttribute({ type: () => String, name: 'lang' })\n *   language: string;\n *\n *   constructor(d?: Comment) {\n *     Object.assign(this, d || {});\n *   }\n * }\n *\n * classToXml(\n *   new Comment({\n *     text: 'This is awesome',\n *     language: 'en',\n *   }),\n * )\n * ```\n *\n * Output:\n * ```xml\n * <Comment lang=\"en\">This is awesome</Comment>\n * ```\n */\nexport function XmlChardata(opts: XmlChardataOptions): PropertyDecorator {\n  return propertyDecoratorFactory('XmlChardata', {\n    ...opts,\n    chardata: true,\n  });\n}\n\nfunction propertyDecoratorFactory(\n  decoratorName: 'XmlAttribute' | 'XmlChildElem' | 'XmlChardata',\n  opts: InternalXmlPropertyOptions,\n): PropertyDecorator {\n  return (target: { constructor: any }, propertyKey: string | symbol): void => {\n    if (typeof propertyKey !== 'string') {\n      // Dont support symbols for now\n      throw new TypeError(\n        `xml-class-transformer: Can't use @${decoratorName}({...}) decorator on a symbol property ` +\n          `at ${target.constructor.name}#${propertyKey.toString()}`,\n      );\n    }\n\n    if (opts.union && opts.type) {\n      throw new TypeError(\n        `xml-class-transformer: The \"union\" option is not compatible with the \"type\" option at ` +\n          `${target.constructor.name}#${propertyKey.toString()}.`,\n      );\n    }\n\n    if (!opts.union && !opts.type) {\n      throw new TypeError(\n        `xml-class-transformer: No \"type\" or \"union\" was specified for the ` +\n          `${target.constructor.name}#${propertyKey.toString()}. Add it to ` +\n          `the @${decoratorName}({...}) decorator.`,\n      );\n    }\n\n    if (opts.union && !opts.union().length) {\n      throw new TypeError(\n        `xml-class-transformer: The \"union\" option in @${decoratorName}({ ... }) can't be empty ` +\n          `at ${\n            target.constructor.name\n          }#${propertyKey.toString()}. Either remove the \"union\" option or provide it with at least one type.`,\n      );\n    }\n\n    if (opts.union) {\n      if (opts.name) {\n        throw new TypeError(\n          `xml-class-transformer: The \"union\" option is not compatible with the \"name\" option at ` +\n            `${target.constructor.name}#${propertyKey.toString()}. ` +\n            `XML element names for the union members should be specified at ` +\n            `the union member classes.`,\n        );\n      }\n    } else {\n      opts.name = opts.name || propertyKey;\n    }\n\n    if (opts.union) {\n      // opts.union() at the moment of running this peace of code can potentially return\n      // undefineds as the value of some elements in case if there are circular dependencies.\n      // But the primitive values constructors (String, Number and Boolean) are always defined.\n      // So it's okay to check them like this:\n      const unionArr = opts.union();\n      const foundPrimitiveType = unionArr.find((type) => isPrimitiveType(type));\n\n      if (foundPrimitiveType) {\n        throw new TypeError(\n          `xml-class-transformer: unions of primitive types (String, Number or Boolean) are not supported. ` +\n            `Fix it in the decorator @${decoratorName}({ ` +\n            `union: ${serializeUnionForLog(unionArr)}, ... }) ` +\n            `at \"${target.constructor.name}#${propertyKey.toString()}\".`,\n        );\n      }\n    }\n\n    registry.setPropertyOptions(target.constructor, propertyKey, opts);\n  };\n}\n"],"names":[],"mappings":"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"}